{"version":3,"sources":["Viz/Node/Node.jsx","Viz/Algorithms/utilities.js","Viz/Algorithms/PathFinding/aStar.js","Viz/Algorithms/PathFinding/algorithms.js","Viz/Algorithms/PathFinding/bfs.js","Viz/Algorithms/PathFinding/dfs.js","Viz/Algorithms/PathFinding/dijkstra.js","Viz/Algorithms/Maze/backtrack.js","Viz/Algorithms/Maze/algorithms.js","Viz/Algorithms/Maze/kruskal.js","Viz/Viz.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","nodeType","onMouseDown","onMouseEnter","onMouseUp","draggable","className","concat","trim","Component","Type","directionsNoDiag","directionsWithDiag","shuffle","array","rand","temp","cur","length","Math","floor","random","getNeighbors","grid","node","diag","rows","cols","directions","neighbors","i","dir","newRow","newCol","push","PriorityQueue","comparator","a","b","heap","_comparator","item","Error","_swimUp","size","_sinkDown","pop","index","idx","left","right","smallest","parent","DisjointSet","numOfItems","sets","Array","sizes","itemA","itemB","rootA","_getRoot","rootB","aStar","start","goal","heuristic","key","undefined","dx","abs","dy","SQRT2","min","open","f","visitedInOrder","dict","distance","opened","add","isEmpty","poll","closed","neighbor","travelDistance","newDistance","slice","updateItem","PathAlgo","q","shift","path","visited","newPath","stk","backtrackHelper","pathNodesInOrder","randDirections","direction","dirRow","dirCol","MazeAlgo","edges","j","forest","indexA","indexB","find","union","INITIAL_START","r","c","INITIAL_GOAL","Viz","state","initGrid","pathAlgo","mazeAlgo","dragType","disabled","mouseIsPressed","animationSpeed","document","title","curRow","assignType","prevNodeType","Infinity","curType","setNodeType","setState","revertNodeType","querySelectorAll","forEach","element","event","target","checked","mode","value","curNode","nextNode","clearCache","t0","performance","now","executionTime","console","log","getPathLength","disableInput","nodesToAnimate","setTimeout","enableInput","onClick","clearBoard","type","id","onChange","e","setDiag","htmlFor","setPathAlgo","Object","keys","map","option","animateSearch","setMazeAlgo","generateMaze","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.6c2684d6.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      nodeType,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n\n    return (\n      <div\n        // prevent from dragging\n        draggable=\"false\"\n        // render by type\n        className={\"node\".concat(\" \", nodeType).trim()}\n        // mouse event functions\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","// node types\nexport const Type = {\n  Empty: \"\",\n  Wall: \"wall\",\n  Start: \"start\",\n  Goal: \"goal\",\n  Visited: \"visited\",\n  Path: \"path\",\n};\n\n// grid directions with no diagonals\nexport const directionsNoDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n];\n\n// grid directions with diagonals\nexport const directionsWithDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n  // diagonal\n  [1, 1], // bottom right\n  [1, -1], // up right\n  [-1, -1], // up left\n  [-1, 1], // bottom left\n];\n// shuffle an array (for randomizing directions)\nexport function shuffle(array) {\n  let rand, temp, cur;\n  for (cur = array.length - 1; cur > 0; cur--) {\n    rand = Math.floor(Math.random() * (cur + 1));\n    temp = array[cur];\n    array[cur] = array[rand];\n    array[rand] = temp;\n  }\n}\n\n// get neighbors given cell and diagonal movement boolean(ignores wall)\nexport function getNeighbors(grid, node, diag) {\n  if (!grid.length) {\n    return [];\n  }\n\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const directions = diag ? directionsWithDiag : directionsNoDiag;\n\n  let neighbors = [];\n  for (let i = 0; i < directions.length; i++) {\n    let dir = directions[i];\n    let newRow = node.row + dir[0];\n    let newCol = node.col + dir[1];\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol].nodeType !== Type.Wall\n    ) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n\n  return neighbors;\n}\n\n// A custom min/max heap (given comparator)\nexport class PriorityQueue {\n  constructor(comparator = (a, b) => a - b) {\n    this.heap = [];\n    this._comparator = comparator;\n  }\n\n  // cannot add null to heap\n  add(item) {\n    if (item === null) {\n      throw new Error(\"Item cannot be null!\");\n    }\n\n    // add to the end and heapify\n    this.heap.push(item);\n    this._swimUp(this.size() - 1);\n    return true;\n  }\n\n  // clear all items in heap\n  clear() {\n    this.heap = [];\n  }\n\n  // return null if heap is empty\n  peek() {\n    return this.size() === 0 ? null : this.heap[0];\n  }\n\n  // update item if item is modified (do nothing if not found)\n  updateItem(item) {\n    for (let i = 0; i < this.size(); i++) {\n      if (this.heap[i] === item) {\n        this._sinkDown(i);\n        this._swimUp(i);\n      }\n    }\n  }\n\n  // remove and return the min/max of the heap (return null if empty)\n  poll() {\n    if (this.size() <= 1) {\n      return this.heap.pop();\n    }\n\n    // swap the last node and root then heapify\n    let item = this.heap[0];\n    this.heap[0] = this.heap.pop();\n\n    this._sinkDown(0);\n    return item;\n  }\n\n  // return size of heap\n  size() {\n    return this.heap.length;\n  }\n\n  // true/false if heap is empty\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  // heapify a node with given index downwards\n  _sinkDown(index) {\n    let idx = index;\n    while (idx < this.size()) {\n      // both children\n      let left = 2 * idx + 1;\n      let right = 2 * idx + 2;\n      let smallest = idx;\n\n      // Sink down with the smallest children\n      if (\n        left < this.size() &&\n        this._comparator(this.heap[idx], this.heap[left]) > 0\n      ) {\n        smallest = left;\n      }\n\n      if (\n        right < this.size() &&\n        this._comparator(this.heap[smallest], this.heap[right]) > 0\n      ) {\n        smallest = right;\n      }\n\n      // if current node is the smallest, done\n      if (smallest === idx) {\n        return;\n      }\n\n      // swap\n      let temp = this.heap[idx];\n      this.heap[idx] = this.heap[smallest];\n      this.heap[smallest] = temp;\n\n      idx = smallest;\n    }\n  }\n\n  // heapify a node with given index upwards\n  _swimUp(index) {\n    let idx = index;\n    while (idx > 0) {\n      let parent = Math.floor((idx - 1) / 2);\n      // Swim up if parent is greater than children\n      if (this._comparator(this.heap[parent], this.heap[idx]) > 0) {\n        // swap\n        let temp = this.heap[parent];\n        this.heap[parent] = this.heap[idx];\n        this.heap[idx] = temp;\n\n        idx = parent;\n      } else {\n        return;\n      }\n    }\n  }\n}\n\n// A custom data structure for union find\nexport class DisjointSet {\n  constructor(numOfItems) {\n    // parent array\n    this.sets = new Array(numOfItems);\n    // size array\n    this.sizes = new Array(numOfItems);\n\n    for (let i = 0; i < numOfItems; i++) {\n      this.sets[i] = i;\n      this.sizes[i] = 1;\n    }\n  }\n\n  // merge two items' sets together\n  union(itemA, itemB) {\n    let rootA = this._getRoot(itemA);\n    let rootB = this._getRoot(itemB);\n\n    if (rootA === rootB) {\n      return;\n    }\n\n    if (this.sizes[rootA] < this.sizes[rootB]) {\n      // make rootA a subTree of rootB\n      this.sets[rootA] = rootB;\n      this.sizes[rootB] += this.sizes[rootA];\n    } else {\n      // make rootB a subTree of rootA\n      this.sets[rootB] = rootA;\n      this.sizes[rootA] += this.sizes[rootB];\n    }\n\n  }\n\n  // return if two items are in the same set\n  find(itemA, itemB) {\n    return this._getRoot(itemA) === this._getRoot(itemB);\n  }\n\n  // get root of current item\n  _getRoot(item) {\n    let index = item;\n    // while not the root of item (root of root is itself)\n    while (this.sets[index] !== index) {\n      index = this.sets[index];\n    }\n\n    return index;\n  }\n}\n","import {getNeighbors, PriorityQueue} from \"../utilities\";\n\n// Pathfinding with A*\nexport function aStar(grid, start, goal, diag, heuristic) {\n\n  // if heuristic function is not provided\n  if (heuristic === undefined) {\n    if (diag) {\n      // octile distance for diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return 1 * (dx + dy) + (Math.SQRT2 - 2 * 1) * Math.min(dx, dy);\n      };\n    } else {\n      // manhattan distance for non-diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return dx + dy;\n      };\n    }\n  }\n\n  // custom hash value for node\n  function key(node) {\n    return \"\".concat(node.row, \" \", node.col);\n  }\n\n  var open = new PriorityQueue((a, b) => {\n    return a.f - b.f;\n  });\n  var visitedInOrder = [];\n\n  // (K, V) => (node, path to node from start)\n  var dict = {};\n\n  start.distance = 0;\n  start.f = 0;\n  start.opened = true;\n  dict[key(start)] = [start];\n  open.add(start);\n\n  while (!open.isEmpty()) {\n    let node = open.poll();\n    node.closed = true;\n\n    visitedInOrder.push(node);\n    if (node === goal) {\n      // return path and visited nodes\n      return [dict[key(node)], visitedInOrder];\n    }\n\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      // 1 for no diagonal, SQRT2 for diagonal\n      let travelDistance =\n        neighbor.row - node.row === 0 || neighbor.col - node.col === 0\n          ? 1\n          : Math.SQRT2;\n      let newDistance = node.distance + travelDistance;\n\n      // if not processed or should be updated\n      if (!neighbor.opened || newDistance < neighbor.distance) {\n        neighbor.distance = newDistance;\n        neighbor.f = neighbor.distance + heuristic(neighbor, goal);\n\n        // push new path to hash table\n        dict[key(neighbor)] = dict[key(node)].slice();\n        dict[key(neighbor)].push(neighbor);\n\n        if (!neighbor.opened) {\n          open.add(neighbor);\n          neighbor.opened = true;\n        } else {\n          // update because we've updated f value\n          open.updateItem(neighbor);\n        }\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { dfs } from \"./dfs.js\";\nimport { bfs } from \"./bfs.js\";\nimport { dijkstra } from \"./dijkstra.js\";\nimport { aStar } from \"./aStar\";\n\n// Pathfinding algorithm selector\nexport const PathAlgo = {\n  \"---\": function init() {\n    return [[], []];\n  },\n  \"A*\": aStar,\n  \"BFS\": bfs,\n  \"DFS\": dfs,\n  \"Dijkstra\": dijkstra,\n};\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Breadth First Search\nexport function bfs(grid, start, goal, diag) {\n  var q = [];\n  var visitedInOrder = [];\n\n  q.push([start, [start]]);\n\n  while (!!q.length) {\n    let [node, path] = q.shift();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to queue for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        q.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Depth First Search \nexport function dfs(grid, start, goal, diag) {\n  var stk = [];\n  var visitedInOrder = [];\n\n  stk.push([start, [start]]);\n\n  while (!!stk.length) {\n    let [node, path] = stk.pop();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to stack for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        stk.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { aStar } from \"./aStar\";\n\n// Path Finding with Dijkstra's Algorithm\nexport function dijkstra(grid, start, goal, diag) {\n  function heuristic(a, b) {\n    return 0;\n  }\n  // dijkstra is A* with no heuristic function\n  return aStar(grid, start, goal, diag, heuristic);\n}\n","import { Type, directionsNoDiag, shuffle } from \"../utilities\";\n\n// maze generator with recursive backtracking\nexport function backtrack(grid, start) {\n  let pathNodesInOrder = []\n  backtrackHelper(grid, start, pathNodesInOrder);\n  return pathNodesInOrder;\n}\n\nfunction backtrackHelper(grid, node, pathNodesInOrder) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  let randDirections = directionsNoDiag.slice();\n\n  shuffle(randDirections);\n  node.visited = true;\n\n  for (let i = 0; i < randDirections.length; i++) {\n    let direction = randDirections[i];\n    \n    // next node (2 becuase there are walls in between)\n    let newRow = node.row + 2 * direction[0];\n    let newCol = node.col + 2 * direction[1];\n\n    // if next node is within grid and visited (and not a goal)\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol] !== Type.Goal &&\n      !grid[newRow][newCol].visited\n    ) {\n\n      // midpoint of current node and next node\n      let dirRow = Math.floor((newRow + node.row) / 2);\n      let dirCol = Math.floor((newCol + node.col) / 2);\n\n      // add cells to path\n      pathNodesInOrder.push(node);\n      pathNodesInOrder.push(grid[dirRow][dirCol]);\n      pathNodesInOrder.push(grid[newRow][newCol]);\n\n      // backtrack\n      backtrackHelper(grid, grid[newRow][newCol], pathNodesInOrder);\n    }\n  }\n\n  return pathNodesInOrder;\n}\n","import { backtrack } from \"./backtrack.js\";\nimport { kruskal } from \"./kruskal.js\";\n\n// Maze Generation algorithm selector\nexport const MazeAlgo = {\n  \"---\": function init() {\n    return [];\n  },\n  \"Recursive Backtracking\": backtrack,\n  \"Kruskal\": kruskal,\n};\n","import { DisjointSet, shuffle } from \"../utilities\";\n\n// maze generator with kruskal's algorithm (union find)\nexport function kruskal(grid, start) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  let pathNodesInOrder = [];\n\n  let edges = [];\n\n  for (let i = 1; i < rows - 1; i += 2) {\n    for (let j = 1; j < cols - 1; j += 2) {\n      // vertical path (2 rows below)\n      edges.push([i, j, [2, 0]]);\n      // horizontal path (2 cols to the right)\n      edges.push([i, j, [0, 2]]);\n    }\n  }\n\n  // shuffle path\n  shuffle(edges);\n\n  var forest = new DisjointSet(rows * cols);\n\n  while (!!edges.length) {\n    // get random path\n    let [row, col, direction] = edges.pop();\n\n    let newRow = row + direction[0];\n    let newCol = col + direction[1];\n\n    // node is represented by its number in grid\n    let indexA = row * rows + col;\n    let indexB = newRow * rows + newCol;\n\n    // neighbor node is out of bounds\n    if (newRow >= rows || newCol >= cols) {\n      continue;\n    }\n\n    // if current node and next node is not reachable\n    if (!forest.find(indexA, indexB)) {\n      // make it reachable\n      forest.union(indexA, indexB);\n\n      // midpoint of current node and next node\n      let dirRow = Math.floor((newRow + row) / 2);\n      let dirCol = Math.floor((newCol + col) / 2);\n\n      // push maze node\n      pathNodesInOrder.push(grid[row][col]);\n      pathNodesInOrder.push(grid[dirRow][dirCol]);\n\n      // prevent from node going on boundary\n      if (newRow < rows - 1 && newCol < cols - 1) {\n        pathNodesInOrder.push(grid[newRow][newCol]);\n      }\n    }\n  }\n\n  return pathNodesInOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { Type } from \"./Algorithms/utilities\";\nimport { PathAlgo } from \"./Algorithms/PathFinding/algorithms\";\nimport { MazeAlgo } from \"./Algorithms/Maze/algorithms\";\n\nimport \"./Viz.css\";\n\n// Constants\n\nconst INITIAL_ROWS = 27;\nconst INITIAL_COLS = 51;\n\nconst INITIAL_START = { r: 10, c: 10 };\nconst INITIAL_GOAL = { r: 10, c: 41 };\n\nconst ANIMATION_SPEED = 20;\n\nexport default class Viz extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // grid state\n      start: INITIAL_START,\n      goal: INITIAL_GOAL,\n      grid: this.initGrid(INITIAL_ROWS, INITIAL_COLS),\n\n      // current algorithm\n      pathAlgo: \"---\",\n      mazeAlgo: \"---\",\n\n      // diagonal movement\n      diag: false,\n\n      // mouse states\n      dragType: Type.Empty,\n      disabled: false,\n      mouseIsPressed: false,\n\n      // current animation speed\n      animationSpeed: ANIMATION_SPEED,\n    };\n  }\n\n  // Tab Name\n  componentDidMount() {\n    document.title = \"Path Visualizer\";\n  }\n\n  /* Grid Functions */\n\n  // initial grid functions\n  initGrid(rows, cols) {\n    const grid = [];\n    for (let row = 0; row < rows; row++) {\n      const curRow = [];\n      for (let col = 0; col < cols; col++) {\n        let assignType = Type.Empty;\n        if (INITIAL_START.r === row && INITIAL_START.c === col) {\n          assignType = Type.Start;\n        }\n        if (INITIAL_GOAL.r === row && INITIAL_GOAL.c === col) {\n          assignType = Type.Goal;\n        }\n\n        // initial node properties\n        let node = {\n          row: row,\n          col: col,\n          prevNodeType: Type.Empty,\n          nodeType: assignType,\n          visited: false,\n          distance: Infinity,\n          f: Infinity,\n          opened: false,\n          closed: false,\n        };\n\n        curRow.push(node);\n      }\n      grid.push(curRow);\n    }\n    return grid;\n  }\n\n  // clear all the wall/visited/path nodes\n  clearBoard() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[r].length; c++) {\n        const curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(r, c, Type.Empty);\n        } else {\n          // prevent from start/goal reverting to anything other than empty nodes\n          grid[r][c].prevNodeType = Type.Empty;\n        }\n      }\n    }\n\n    this.setState(grid);\n  }\n\n  // clear node caches before starting next search/animation\n  clearCache() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        // clear data\n        grid[r][c].visited = false;\n        grid[r][c].opened = false;\n        grid[r][c].closed = false;\n\n        grid[r][c].distance = Infinity;\n        grid[r][c].f = Infinity;\n\n        let curType = grid[r][c].nodeType;\n\n        // clear visited cache\n        if (curType === Type.Visited || curType === Type.Path) {\n          this.setNodeType(r, c, Type.Empty);\n        }\n\n        // prevent from reverting to types from previous search\n        grid[r][c].prevNodeType = Type.Empty;\n      }\n    }\n\n    this.setState(grid);\n  }\n\n  /* Node Functions */\n\n  // set node given type, set current type to previous type accordingly\n  setNodeType(row, col, assignType) {\n    const { grid } = this.state;\n    if (grid[row][col].nodeType !== assignType) {\n      grid[row][col].prevNodeType = grid[row][col].nodeType;\n    }\n    grid[row][col].nodeType = assignType;\n  }\n\n  // revert node type to its previous  type\n  revertNodeType(row, col) {\n    const { grid } = this.state;\n    grid[row][col].nodeType = grid[row][col].prevNodeType;\n  }\n\n  /* Mouse Events */\n\n  // mouse down event\n  handleMouseDown(row, col) {\n    const { grid, disabled } = this.state;\n\n    if (disabled) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n\n    switch (curType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        this.setNodeType(row, col, Type.Wall);\n        break;\n      case Type.Wall:\n        // revert wall nodes to previous type\n        this.revertNodeType(row, col);\n        break;\n      default:\n        break;\n    }\n\n    this.setState({\n      grid: grid,\n      dragType: curType,\n      mouseIsPressed: true,\n    });\n  }\n\n  // mouse hover event\n  handleMouseEnter(row, col) {\n    const {\n      grid,\n      start,\n      goal,\n      disabled,\n      mouseIsPressed,\n      dragType,\n    } = this.state;\n\n    // ignore if disabled or mouse is not pressed\n    if (disabled || !mouseIsPressed) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n    switch (dragType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(row, col, Type.Wall);\n        }\n        break;\n      case Type.Wall:\n        // revert to previous types\n        if (curType === Type.Wall) {\n          this.revertNodeType(row, col);\n        }\n        break;\n      case Type.Start:\n        // move start and revert previous start\n        if (curType !== Type.Wall && curType !== Type.Goal) {\n          this.revertNodeType(start.r, start.c);\n          this.setNodeType(row, col, Type.Start);\n          this.setState({ start: { r: row, c: col } });\n        }\n        break;\n      case Type.Goal:\n        // move goal and revert previous goal\n        if (curType !== Type.Wall && curType !== Type.Start) {\n          this.revertNodeType(goal.r, goal.c);\n          this.setNodeType(row, col, Type.Goal);\n          this.setState({ goal: { r: row, c: col } });\n        }\n        break;\n      default:\n    }\n\n    this.setState(grid);\n  }\n\n  // mouse up event\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  /* Pathfinding Algorithm Functions */\n\n  // disable all inputs\n  disableInput() {\n    var elements = document.querySelectorAll(\"button\");\n    elements.forEach((element) => (element.disabled = true));\n    this.setState({ disabled: true });\n  }\n\n  // enable all inputs\n  enableInput() {\n    var elements = document.querySelectorAll(\"button\");\n    elements.forEach((element) => (element.disabled = false));\n    this.setState({ disabled: false });\n  }\n\n  // set diagonal movement\n  setDiag(event) {\n    this.setState({ diag: event.target.checked });\n  }\n\n  // set pathfinding algorithm\n  setPathAlgo(event) {\n    let mode = event.target.value;\n\n    if (!(mode in PathAlgo)) {\n      // not a valid algorithm\n      return;\n    }\n    this.setState({ pathAlgo: mode });\n  }\n\n  // calculate path length\n  getPathLength(path) {\n    let length = 0;\n    for (let i = 0; i < path.length - 1; i++) {\n      let curNode = path[i];\n      let nextNode = path[i + 1];\n      let dx = Math.abs(curNode.row - nextNode.row);\n      let dy = Math.abs(curNode.col - nextNode.col);\n\n      length += dx === 0 || dy === 0 ? 1 : Math.SQRT2;\n    }\n\n    return length;\n  }\n\n  // animate pathfinding algorithms\n  animateSearch() {\n    const { grid, start, goal, pathAlgo, diag, animationSpeed } = this.state;\n\n    // clear cache\n    this.clearCache();\n\n    let t0 = performance.now();\n\n    // perform search\n    const [path, visitedInOrder] = PathAlgo[pathAlgo](\n      grid,\n      grid[start.r][start.c],\n      grid[goal.r][goal.c],\n      diag\n    );\n\n    let executionTime = performance.now() - t0;\n    console.log(executionTime);\n\n    // get path length\n    let length = this.getPathLength(path);\n    console.log(length);\n\n    // disable input during animation\n    this.disableInput();\n\n    // concatenate all nodes to animate\n    const nodesToAnimate = visitedInOrder.concat(path);\n\n    for (let i = 0; i < nodesToAnimate.length; i++) {\n      let node = nodesToAnimate[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        if (\n          node.nodeType === Type.Start &&\n          nodesToAnimate.length === visitedInOrder.length\n        ) {\n          // no path found\n          node.prevNodeType = Type.Visited;\n          continue;\n        }\n        // set start/goal nodes previous type to path for indicate path when moving start/goal\n        node.prevNodeType = Type.Path;\n        continue;\n      }\n\n      let assignType = i < visitedInOrder.length ? Type.Visited : Type.Path;\n      setTimeout(() => {\n        node.nodeType = assignType;\n\n        // set state for new render (force animation)\n        this.setState({ grid });\n      }, animationSpeed * i);\n    }\n\n    // enable input after animation\n    setTimeout(() => {\n      this.enableInput();\n    }, animationSpeed * nodesToAnimate.length);\n  }\n\n  /* Maze Functions */\n\n  // set maze generation algorithm\n  setMazeAlgo(event) {\n    let mode = event.target.value;\n\n    if (!(mode in MazeAlgo)) {\n      // not a valid algorithm\n      return;\n    }\n    this.setState({ mazeAlgo: mode });\n  }\n\n  // animate maze generation\n  generateMaze() {\n    const { grid, start, animationSpeed, mazeAlgo } = this.state;\n\n    let t0 = performance.now();\n\n    let pathNodesInOrder = MazeAlgo[mazeAlgo](grid, grid[start.r][start.c]);\n\n    let executionTime = performance.now() - t0;\n    console.log(executionTime);\n\n    // clear all cache\n    this.clearCache();\n\n    // disable input during animation\n    this.disableInput();\n\n    // set all cells to wall\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        let curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          // Walls with no zoom effect\n          this.setNodeType(r, c, \"wall-still\");\n        }\n      }\n    }\n\n    // force render\n    this.setState({ grid });\n\n    // animation maze\n    for (let i = 0; i < pathNodesInOrder.length; i++) {\n      let node = pathNodesInOrder[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        continue;\n      }\n      setTimeout(() => {\n        node.nodeType = Type.Empty;\n        // set state for new render (force animation)\n        this.setState({ grid });\n      }, animationSpeed * i);\n    }\n\n    // enable input after animation\n    setTimeout(() => {\n      this.enableInput();\n    }, animationSpeed * pathNodesInOrder.length);\n  }\n\n  /* Render */\n\n  render() {\n    const { grid } = this.state;\n\n    return (\n      <>\n        <div className=\"panel\">\n          <button onClick={() => this.clearBoard()}> Clear Board </button>\n          <input\n            type=\"checkbox\"\n            id=\"checkbox\"\n            onChange={(e) => this.setDiag(e)}\n          ></input>\n          <label htmlFor=\"checkbox\">Allow Diagonal Movements</label>\n          <select id=\"path\" onChange={(e) => this.setPathAlgo(e)}>\n            {Object.keys(PathAlgo).map((option, index) => (\n              <option key={index} value={option}>\n                {option}\n              </option>\n            ))}\n          </select>\n          <button onClick={() => this.animateSearch()}>Start Search</button>\n          <select id=\"maze\" onChange={(e) => this.setMazeAlgo(e)}>\n            {Object.keys(MazeAlgo).map((option, index) => (\n              <option key={index} value={option}>\n                {option}\n              </option>\n            ))}\n          </select>\n          <button onClick={() => this.generateMaze()}>Generate Maze</button>\n        </div>\n\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, nodeType } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      row={row}\n                      col={col}\n                      nodeType={nodeType}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n","import \"./App.css\";\nimport Viz from \"./Viz/Viz\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {\" \"}\n      <Viz></Viz>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}