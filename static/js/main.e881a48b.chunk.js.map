{"version":3,"sources":["Viz/Node/Node.jsx","Viz/Algorithms/utilities.js","Viz/Algorithms/PathFinding/aStar.js","Viz/Algorithms/PathFinding/algorithms.js","Viz/Algorithms/PathFinding/bfs.js","Viz/Algorithms/PathFinding/dfs.js","Viz/Algorithms/PathFinding/dijkstra.js","Viz/Algorithms/Maze/backtrack.js","Viz/Algorithms/Maze/algorithms.js","Viz/Algorithms/Maze/kruskal.js","Viz/Viz.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","nodeType","onMouseDown","onMouseEnter","onMouseUp","className","concat","trim","Component","Type","directionsNoDiag","directionsWithDiag","shuffle","array","rand","temp","cur","length","Math","floor","random","getNeighbors","grid","node","diag","rows","cols","directions","neighbors","i","dir","newRow","newCol","push","PriorityQueue","comparator","a","b","heap","_comparator","item","Error","_swimUp","size","_sinkDown","pop","index","idx","left","right","smallest","parent","DisjointSet","numOfItems","sets","Array","sizes","itemA","itemB","rootA","_getRoot","rootB","aStar","start","goal","heuristic","key","undefined","dx","abs","dy","SQRT2","min","open","f","visitedInOrder","dict","distance","opened","add","isEmpty","poll","closed","neighbor","travelDistance","newDistance","slice","updateItem","PathAlgo","q","shift","path","visited","newPath","stk","backtrackHelper","pathNodesInOrder","randDirections","direction","dirRow","dirCol","MazeAlgo","edges","j","forest","indexA","indexB","find","union","INITIAL_START","r","c","INITIAL_GOAL","Viz","state","initGrid","pathAlgo","mazeAlgo","dragType","disabled","mouseIsPressed","animationSpeed","document","title","curRow","assignType","prevNodeType","Infinity","curType","setNodeType","setState","revertNodeType","querySelectorAll","forEach","element","event","target","checked","mode","value","clearCache","disableInput","nodesToAnimate","setTimeout","enableInput","onClick","clearBoard","type","id","onChange","e","setDiag","htmlFor","setPathAlgo","Object","keys","map","option","animateSearch","setMazeAlgo","generateMaze","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.e881a48b.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      nodeType,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n\n    return (\n      <div\n        // render by type\n        className={\"node\".concat(\" \", nodeType).trim()}\n        // mouse event functions\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","// node types\nexport const Type = {\n  Empty: \"\",\n  Wall: \"wall\",\n  Start: \"start\",\n  Goal: \"goal\",\n  Visited: \"visited\",\n  Path: \"path\",\n};\n\n// grid directions with no diagonals\nexport const directionsNoDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n];\n\n// grid directions with diagonals\nexport const directionsWithDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n  // diagonal\n  [1, 1], // bottom right\n  [1, -1], // up right\n  [-1, -1], // up left\n  [-1, 1], // bottom left\n];\n// shuffle an array (for randomizing directions)\nexport function shuffle(array) {\n  let rand, temp, cur;\n  for (cur = array.length - 1; cur > 0; cur--) {\n    rand = Math.floor(Math.random() * (cur + 1));\n    temp = array[cur];\n    array[cur] = array[rand];\n    array[rand] = temp;\n  }\n}\n\n// get neighbors given cell and diagonal movement boolean(ignores wall)\nexport function getNeighbors(grid, node, diag) {\n  if (!grid.length) {\n    return [];\n  }\n\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const directions = diag ? directionsWithDiag : directionsNoDiag;\n\n  let neighbors = [];\n  for (let i = 0; i < directions.length; i++) {\n    let dir = directions[i];\n    let newRow = node.row + dir[0];\n    let newCol = node.col + dir[1];\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol].nodeType !== Type.Wall\n    ) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n\n  return neighbors;\n}\n\n// A custom min/max heap (given comparator)\nexport class PriorityQueue {\n  constructor(comparator = (a, b) => a - b) {\n    this.heap = [];\n    this._comparator = comparator;\n  }\n\n  // cannot add null to heap\n  add(item) {\n    if (item === null) {\n      throw new Error(\"Item cannot be null!\");\n    }\n\n    // add to the end and heapify\n    this.heap.push(item);\n    this._swimUp(this.size() - 1);\n    return true;\n  }\n\n  // clear all items in heap\n  clear() {\n    this.heap = [];\n  }\n\n  // return null if heap is empty\n  peek() {\n    return this.size() === 0 ? null : this.heap[0];\n  }\n\n  // update item if item is modified (do nothing if not found)\n  updateItem(item) {\n    for (let i = 0; i < this.size(); i++) {\n      if (this.heap[i] === item) {\n        this._sinkDown(i);\n        this._swimUp(i);\n      }\n    }\n  }\n\n  // remove and return the min/max of the heap (return null if empty)\n  poll() {\n    if (this.size() <= 1) {\n      return this.heap.pop();\n    }\n\n    // swap the last node and root then heapify\n    let item = this.heap[0];\n    this.heap[0] = this.heap.pop();\n\n    this._sinkDown(0);\n    return item;\n  }\n\n  // return size of heap\n  size() {\n    return this.heap.length;\n  }\n\n  // true/false if heap is empty\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  // heapify a node with given index downwards\n  _sinkDown(index) {\n    let idx = index;\n    while (idx < this.size()) {\n      // both children\n      let left = 2 * idx + 1;\n      let right = 2 * idx + 2;\n      let smallest = idx;\n\n      // Sink down with the smallest children\n      if (\n        left < this.size() &&\n        this._comparator(this.heap[idx], this.heap[left]) > 0\n      ) {\n        smallest = left;\n      }\n\n      if (\n        right < this.size() &&\n        this._comparator(this.heap[smallest], this.heap[right]) > 0\n      ) {\n        smallest = right;\n      }\n\n      // if current node is the smallest, done\n      if (smallest === idx) {\n        return;\n      }\n\n      // swap\n      let temp = this.heap[idx];\n      this.heap[idx] = this.heap[smallest];\n      this.heap[smallest] = temp;\n\n      idx = smallest;\n    }\n  }\n\n  // heapify a node with given index upwards\n  _swimUp(index) {\n    let idx = index;\n    while (idx > 0) {\n      let parent = Math.floor((idx - 1) / 2);\n      // Swim up if parent is greater than children\n      if (this._comparator(this.heap[parent], this.heap[idx]) > 0) {\n        // swap\n        let temp = this.heap[parent];\n        this.heap[parent] = this.heap[idx];\n        this.heap[idx] = temp;\n\n        idx = parent;\n      } else {\n        return;\n      }\n    }\n  }\n}\n\n// A custom data structure for union find\nexport class DisjointSet {\n  constructor(numOfItems) {\n    // parent array\n    this.sets = new Array(numOfItems);\n    // size array\n    this.sizes = new Array(numOfItems);\n\n    for (let i = 0; i < numOfItems; i++) {\n      this.sets[i] = i;\n      this.sizes[i] = 1;\n    }\n  }\n\n  // merge two items' sets together\n  union(itemA, itemB) {\n    let rootA = this._getRoot(itemA);\n    let rootB = this._getRoot(itemB);\n\n    if (rootA === rootB) {\n      return;\n    }\n\n    if (this.sizes[rootA] < this.sizes[rootB]) {\n      // make rootA a subTree of rootB\n      this.sets[rootA] = rootB;\n      this.sizes[rootB] += this.sizes[rootA];\n    } else {\n      // make rootB a subTree of rootA\n      this.sets[rootB] = rootA;\n      this.sizes[rootA] += this.sizes[rootB];\n    }\n\n  }\n\n  // return if two items are in the same set\n  find(itemA, itemB) {\n    return this._getRoot(itemA) === this._getRoot(itemB);\n  }\n\n  // get root of current item\n  _getRoot(item) {\n    let index = item;\n    // while not the root of item (root of root is itself)\n    while (this.sets[index] !== index) {\n      index = this.sets[index];\n    }\n\n    return index;\n  }\n}\n","import {getNeighbors, PriorityQueue} from \"../utilities\";\n\n// Pathfinding with A*\nexport function aStar(grid, start, goal, diag, heuristic) {\n\n  // if heuristic function is not provided\n  if (heuristic === undefined) {\n    if (diag) {\n      // octile distance for diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return 1 * (dx + dy) + (Math.SQRT2 - 2 * 1) * Math.min(dx, dy);\n      };\n    } else {\n      // manhattan distance for non-diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return dx + dy;\n      };\n    }\n  }\n\n  // custom hash value for node\n  function key(node) {\n    return \"\".concat(node.row, \" \", node.col);\n  }\n\n  var open = new PriorityQueue((a, b) => {\n    return a.f - b.f;\n  });\n  var visitedInOrder = [];\n\n  // (K, V) => (node, path to node from start)\n  var dict = {};\n\n  start.distance = 0;\n  start.f = 0;\n  start.opened = true;\n  dict[key(start)] = [start];\n  open.add(start);\n\n  while (!open.isEmpty()) {\n    let node = open.poll();\n    node.closed = true;\n\n    visitedInOrder.push(node);\n    if (node === goal) {\n      // return path and visited nodes\n      return [dict[key(node)], visitedInOrder];\n    }\n\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      // 1 for no diagonal, SQRT2 for diagonal\n      let travelDistance =\n        neighbor.row - node.row === 0 || neighbor.col - node.col === 0\n          ? 1\n          : Math.SQRT2;\n      let newDistance = node.distance + travelDistance;\n\n      // if not processed or should be updated\n      if (!neighbor.opened || newDistance < neighbor.distance) {\n        neighbor.distance = newDistance;\n        neighbor.f = neighbor.distance + heuristic(neighbor, goal);\n\n        // push new path to hash table\n        dict[key(neighbor)] = dict[key(node)].slice();\n        dict[key(neighbor)].push(neighbor);\n\n        if (!neighbor.opened) {\n          open.add(neighbor);\n          neighbor.opened = true;\n        } else {\n          // update because we've updated f value\n          open.updateItem(neighbor);\n        }\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { dfs } from \"./dfs.js\";\nimport { bfs } from \"./bfs.js\";\nimport { dijkstra } from \"./dijkstra.js\";\nimport { aStar } from \"./aStar\";\n\n// Pathfinding algorithm selector\nexport const PathAlgo = {\n  \"---\": function init() {\n    return [[], []];\n  },\n  \"A*\": aStar,\n  \"BFS\": bfs,\n  \"DFS\": dfs,\n  \"Dijkstra\": dijkstra,\n};\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Breadth First Search\nexport function bfs(grid, start, goal, diag) {\n  var q = [];\n  var visitedInOrder = [];\n\n  q.push([start, [start]]);\n\n  while (!!q.length) {\n    let [node, path] = q.shift();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to queue for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        q.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Depth First Search \nexport function dfs(grid, start, goal, diag) {\n  var stk = [];\n  var visitedInOrder = [];\n\n  stk.push([start, [start]]);\n\n  while (!!stk.length) {\n    let [node, path] = stk.pop();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to stack for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        stk.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { aStar } from \"./aStar\";\n\n// Path Finding with Dijkstra's Algorithm\nexport function dijkstra(grid, start, goal, diag) {\n  function heuristic(a, b) {\n    return 0;\n  }\n  // dijkstra is A* with no heuristic function\n  return aStar(grid, start, goal, diag, heuristic);\n}\n","import { Type, directionsNoDiag, shuffle } from \"../utilities\";\n\n// maze generator with recursive backtracking\nexport function backtrack(grid, start) {\n  let pathNodesInOrder = []\n  backtrackHelper(grid, start, pathNodesInOrder);\n  return pathNodesInOrder;\n}\n\nfunction backtrackHelper(grid, node, pathNodesInOrder) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  let randDirections = directionsNoDiag.slice();\n\n  shuffle(randDirections);\n  node.visited = true;\n\n  for (let i = 0; i < randDirections.length; i++) {\n    let direction = randDirections[i];\n    \n    // next node (2 becuase there are walls in between)\n    let newRow = node.row + 2 * direction[0];\n    let newCol = node.col + 2 * direction[1];\n\n    // if next node is within grid and visited (and not a goal)\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol] !== Type.Goal &&\n      !grid[newRow][newCol].visited\n    ) {\n\n      // midpoint of current node and next node\n      let dirRow = Math.floor((newRow + node.row) / 2);\n      let dirCol = Math.floor((newCol + node.col) / 2);\n\n      // add cells to path\n      pathNodesInOrder.push(node);\n      pathNodesInOrder.push(grid[dirRow][dirCol]);\n      pathNodesInOrder.push(grid[newRow][newCol]);\n\n      // backtrack\n      backtrackHelper(grid, grid[newRow][newCol], pathNodesInOrder);\n    }\n  }\n\n  return pathNodesInOrder;\n}\n","import { backtrack } from \"./backtrack.js\";\nimport { kruskal } from \"./kruskal.js\";\n\n// Maze Generation algorithm selector\nexport const MazeAlgo = {\n  \"---\": function init() {\n    return [];\n  },\n  \"Recursive Backtracking\": backtrack,\n  \"Kruskal\": kruskal,\n};\n","import { DisjointSet, shuffle } from \"../utilities\";\n\n// maze generator with kruskal's algorithm (union find)\nexport function kruskal(grid, start) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  let pathNodesInOrder = [];\n\n  let edges = [];\n\n  for (let i = 1; i < rows - 1; i += 2) {\n    for (let j = 1; j < cols - 1; j += 2) {\n      // vertical path (2 rows below)\n      edges.push([i, j, [2, 0]]);\n      // horizontal path (2 cols to the right)\n      edges.push([i, j, [0, 2]]);\n    }\n  }\n\n  // shuffle path\n  shuffle(edges);\n\n  var forest = new DisjointSet(rows * cols);\n\n  while (!!edges.length) {\n    // get random path\n    let [row, col, direction] = edges.pop();\n\n    let newRow = row + direction[0];\n    let newCol = col + direction[1];\n\n    // node is represented by its number in grid\n    let indexA = row * rows + col;\n    let indexB = newRow * rows + newCol;\n\n    // neighbor node is out of bounds\n    if (newRow >= rows || newCol >= cols) {\n      continue;\n    }\n\n    // if current node and next node is not reachable\n    if (!forest.find(indexA, indexB)) {\n      // make it reachable\n      forest.union(indexA, indexB);\n\n      // midpoint of current node and next node\n      let dirRow = Math.floor((newRow + row) / 2);\n      let dirCol = Math.floor((newCol + col) / 2);\n\n      // push maze node\n      pathNodesInOrder.push(grid[row][col]);\n      pathNodesInOrder.push(grid[dirRow][dirCol]);\n\n      // prevent from node going on boundary\n      if (newRow < rows - 1 && newCol < cols - 1) {\n        pathNodesInOrder.push(grid[newRow][newCol]);\n      }\n    }\n  }\n\n  return pathNodesInOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { Type } from \"./Algorithms/utilities\";\nimport { PathAlgo } from \"./Algorithms/PathFinding/algorithms\";\nimport { MazeAlgo } from \"./Algorithms/Maze/algorithms\";\n\nimport \"./Viz.css\";\n\n// Constants\n\nconst INITIAL_ROWS = 27;\nconst INITIAL_COLS = 51;\n\nconst INITIAL_START = { r: 10, c: 10 };\nconst INITIAL_GOAL = { r: 10, c: 41 };\n\nconst ANIMATION_SPEED = 20;\n\nexport default class Viz extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // grid state\n      start: INITIAL_START,\n      goal: INITIAL_GOAL,\n      grid: this.initGrid(INITIAL_ROWS, INITIAL_COLS),\n\n      // current algorithm\n      pathAlgo: \"---\",\n      mazeAlgo: \"---\",\n\n      // diagonal movement\n      diag: false,\n\n      // mouse states\n      dragType: Type.Empty,\n      disabled: false,\n      mouseIsPressed: false,\n\n      // current animation speed\n      animationSpeed: ANIMATION_SPEED,\n    };\n  }\n\n  // Tab Name\n  componentDidMount() {\n    document.title = \"Path Visualizer\";\n  }\n\n  /* Grid Functions */\n\n  // initial grid functions\n  initGrid(rows, cols) {\n    const grid = [];\n    for (let row = 0; row < rows; row++) {\n      const curRow = [];\n      for (let col = 0; col < cols; col++) {\n        let assignType = Type.Empty;\n        if (INITIAL_START.r === row && INITIAL_START.c === col) {\n          assignType = Type.Start;\n        }\n        if (INITIAL_GOAL.r === row && INITIAL_GOAL.c === col) {\n          assignType = Type.Goal;\n        }\n\n        // initial node properties\n        let node = {\n          row: row,\n          col: col,\n          prevNodeType: Type.Empty,\n          nodeType: assignType,\n          visited: false,\n          distance: Infinity,\n          f: Infinity,\n          opened: false,\n          closed: false,\n        };\n\n        curRow.push(node);\n      }\n      grid.push(curRow);\n    }\n    return grid;\n  }\n\n  // clear all the wall/visited/path nodes\n  clearBoard() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[r].length; c++) {\n        const curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(r, c, Type.Empty);\n        } else {\n          // prevent from start/goal reverting to anything other than empty nodes\n          grid[r][c].prevNodeType = Type.Empty;\n        }\n      }\n    }\n\n    this.setState(grid);\n  }\n\n  // clear node caches before starting next search/animation\n  clearCache() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        // clear data\n        grid[r][c].visited = false;\n        grid[r][c].opened = false;\n        grid[r][c].closed = false;\n\n        grid[r][c].distance = Infinity;\n        grid[r][c].f = Infinity;\n\n        let curType = grid[r][c].nodeType;\n\n        // clear visited cache\n        if (curType === Type.Visited || curType === Type.Path) {\n          this.setNodeType(r, c, Type.Empty);\n        }\n\n        // prevent from reverting to types from previous search\n        grid[r][c].prevNodeType = Type.Empty;\n      }\n    }\n\n    this.setState(grid);\n  }\n\n  /* Node Functions */\n\n  // set node given type, set current type to previous type accordingly\n  setNodeType(row, col, assignType) {\n    const { grid } = this.state;\n    if (grid[row][col].nodeType !== assignType) {\n      grid[row][col].prevNodeType = grid[row][col].nodeType;\n    }\n    grid[row][col].nodeType = assignType;\n  }\n\n  // revert node type to its previous  type\n  revertNodeType(row, col) {\n    const { grid } = this.state;\n    grid[row][col].nodeType = grid[row][col].prevNodeType;\n  }\n\n  /* Mouse Events */\n\n  // mouse down event\n  handleMouseDown(row, col) {\n    const { grid, disabled } = this.state;\n\n    if (disabled) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n\n    switch (curType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        this.setNodeType(row, col, Type.Wall);\n        break;\n      case Type.Wall:\n        // revert wall nodes to previous type\n        this.revertNodeType(row, col);\n        break;\n      default:\n        break;\n    }\n\n    this.setState({\n      grid: grid,\n      dragType: curType,\n      mouseIsPressed: true,\n    });\n  }\n\n  // mouse hover event\n  handleMouseEnter(row, col) {\n    const {\n      grid,\n      start,\n      goal,\n      disabled,\n      mouseIsPressed,\n      dragType,\n    } = this.state;\n\n    // ignore if disabled or mouse is not pressed\n    if (disabled || !mouseIsPressed) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n    switch (dragType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(row, col, Type.Wall);\n        }\n        break;\n      case Type.Wall:\n        // revert to previous types\n        if (curType === Type.Wall) {\n          this.revertNodeType(row, col);\n        }\n        break;\n      case Type.Start:\n        // move start and revert previous start\n        if (curType !== Type.Wall && curType !== Type.Goal) {\n          this.revertNodeType(start.r, start.c);\n          this.setNodeType(row, col, Type.Start);\n          this.setState({ start: { r: row, c: col } });\n        }\n        break;\n      case Type.Goal:\n        // move goal and revert previous goal\n        if (curType !== Type.Wall && curType !== Type.Start) {\n          this.revertNodeType(goal.r, goal.c);\n          this.setNodeType(row, col, Type.Goal);\n          this.setState({ goal: { r: row, c: col } });\n        }\n        break;\n      default:\n    }\n\n    this.setState(grid);\n  }\n\n  // mouse up event\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  /* Pathfinding Algorithm Functions */\n\n  // disable all inputs\n  disableInput() {\n    var elements = document.querySelectorAll(\"button, input\");\n    elements.forEach((element) => (element.disabled = true));\n    this.setState({ disabled: true });\n  }\n\n  // enable all inputs\n  enableInput() {\n    var elements = document.querySelectorAll(\"button, input\");\n    elements.forEach((element) => (element.disabled = false));\n    this.setState({ disabled: false });\n  }\n\n  // set diagonal movement\n  setDiag(event) {\n    this.setState({ diag: event.target.checked });\n  }\n\n  // set pathfinding algorithm\n  setPathAlgo(event) {\n    let mode = event.target.value;\n\n    if (!(mode in PathAlgo)) {\n      // not a valid algorithm\n      return;\n    }\n    this.setState({ pathAlgo: mode });\n  }\n\n  // animate pathfinding algorithms\n  animateSearch() {\n    const { grid, start, goal, pathAlgo, diag, animationSpeed } = this.state;\n\n    // clear cache\n    this.clearCache();\n\n    // perform search\n    const [path, visitedInOrder] = PathAlgo[pathAlgo](\n      grid,\n      grid[start.r][start.c],\n      grid[goal.r][goal.c],\n      diag\n    );\n\n    // disable input during animation\n    this.disableInput();\n\n    // concatenate all nodes to animate\n    const nodesToAnimate = visitedInOrder.concat(path);\n\n    for (let i = 0; i < nodesToAnimate.length; i++) {\n      let node = nodesToAnimate[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        if (node.nodeType === Type.Start && nodesToAnimate.length === visitedInOrder.length) {\n          // no path found\n          node.prevNodeType = Type.Visited;\n          continue;\n        }\n        // set start/goal nodes previous type to path for indicate path when moving start/goal\n        node.prevNodeType = Type.Path;\n        continue;\n      }\n\n      let assignType = i < visitedInOrder.length ? Type.Visited : Type.Path;\n      setTimeout(() => {\n        node.nodeType = assignType;\n\n        // set state for new render (force animation)\n        this.setState({ grid });\n      }, animationSpeed * i);\n    }\n\n    // enable input after animation\n    setTimeout(() => {\n      this.enableInput();\n    }, animationSpeed * nodesToAnimate.length);\n  }\n\n  /* Maze Functions */\n\n  // set maze generation algorithm\n  setMazeAlgo(event) {\n    let mode = event.target.value;\n\n    if (!(mode in MazeAlgo)) {\n      // not a valid algorithm\n      return;\n    }\n    this.setState({ mazeAlgo: mode });\n  }\n\n  // animate maze generation\n  generateMaze() {\n    const { grid, start, animationSpeed, mazeAlgo } = this.state;\n\n    let pathNodesInOrder = MazeAlgo[mazeAlgo](grid, grid[start.r][start.c]);\n\n    // clear all cache\n    this.clearCache();\n\n    // disable input during animation\n    this.disableInput();\n\n    // set all cells to wall\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        let curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(r, c, Type.Wall);\n        }\n      }\n    }\n\n    // force render\n    this.setState({ grid });\n\n    // animation maze\n    for (let i = 0; i < pathNodesInOrder.length; i++) {\n      let node = pathNodesInOrder[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        continue;\n      }\n      setTimeout(() => {\n        node.nodeType = Type.Empty;\n        // set state for new render (force animation)\n        this.setState({ grid });\n      }, animationSpeed * i);\n    }\n\n    // enable input after animation\n    setTimeout(() => {\n      this.enableInput();\n    }, animationSpeed * pathNodesInOrder.length);\n  }\n\n  /* Render */\n\n  render() {\n    const { grid } = this.state;\n\n    return (\n      <>\n        <div className=\"panel\">\n          <button onClick={() => this.clearBoard()}> Clear Board </button>\n          <input\n            type=\"checkbox\"\n            id=\"checkbox\"\n            onChange={(e) => this.setDiag(e)}\n          ></input>\n          <label htmlFor=\"checkbox\">Allow Diagonal Movements</label>\n          <select id=\"path\" onChange={(e) => this.setPathAlgo(e)}>\n            {Object.keys(PathAlgo).map((option, index) => (\n              <option key={index} value={option}>\n                {option}\n              </option>\n            ))}\n          </select>\n          <button onClick={() => this.animateSearch()}>Start Search</button>\n          <select id=\"maze\" onChange={(e) => this.setMazeAlgo(e)}>\n            {Object.keys(MazeAlgo).map((option, index) => (\n              <option key={index} value={option}>\n                {option}\n              </option>\n            ))}\n          </select>\n          <button onClick={() => this.generateMaze()}>Generate Maze</button>\n        </div>\n\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, nodeType } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      row={row}\n                      col={col}\n                      nodeType={nodeType}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n","import \"./App.css\";\nimport Viz from \"./Viz/Viz\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {\" \"}\n      <Viz></Viz>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}