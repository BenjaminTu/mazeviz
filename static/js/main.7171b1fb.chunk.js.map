{"version":3,"sources":["Viz/Node/Node.jsx","Viz/Algorithms/utilities.js","Viz/Algorithms/PathFinding/aStar.js","Viz/Algorithms/PathFinding/algorithms.js","Viz/Algorithms/PathFinding/bfs.js","Viz/Algorithms/PathFinding/dfs.js","Viz/Algorithms/PathFinding/dijkstra.js","Viz/Algorithms/Maze/backtrack.js","Viz/Algorithms/Maze/algorithms.js","Viz/Algorithms/Maze/kruskal.js","Viz/Viz.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","nodeType","onMouseDown","onMouseEnter","onMouseUp","draggable","className","concat","trim","Component","Type","directionsNoDiag","directionsWithDiag","shuffle","array","rand","temp","cur","length","Math","floor","random","getNeighbors","grid","node","diag","rows","cols","directions","neighbors","i","dir","newRow","newCol","push","PriorityQueue","comparator","a","b","heap","_comparator","item","Error","_swimUp","size","_sinkDown","pop","index","idx","left","right","smallest","parent","DisjointSet","numOfItems","sets","Array","sizes","itemA","itemB","rootA","_getRoot","rootB","aStar","start","goal","heuristic","key","undefined","dx","abs","dy","SQRT2","min","open","f","visitedInOrder","dict","distance","opened","add","isEmpty","poll","closed","neighbor","travelDistance","newDistance","slice","updateItem","PATH_ALGO","q","shift","path","visited","newPath","stk","backtrackHelper","pathNodesInOrder","randDirections","direction","dirRow","dirCol","MAZE_ALGO","edges","j","forest","indexA","indexB","find","union","INITIAL_START","r","c","INITIAL_GOAL","ANIMATION_SPEED","Instant","Viz","state","initGrid","pathAlgo","mazeAlgo","pathLength","time","dragType","disabled","mouseIsPressed","animationSpeed","document","title","getElementById","curRow","assignType","prevNodeType","Infinity","curType","setNodeType","displayStats","setState","revertNodeType","querySelectorAll","forEach","element","event","target","checked","mode","value","curNode","nextNode","clearCache","t0","performance","now","executionTime","getPathLength","disableInput","nodesToAnimate","setTimeout","enableInput","speed","console","log","href","id","onChange","e","setPathAlgo","selected","Object","keys","map","option","type","setDiag","onClick","animateSearch","clearBoard","setMazeAlgo","generateMaze","setAnimationSpeed","toFixed","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.7171b1fb.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      nodeType,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n\n    return (\n      <div\n        // prevent from dragging\n        draggable=\"false\"\n        // render by type\n        className={\"flex-item node\".concat(\" \", nodeType).trim()}\n        // mouse event functions\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","// node types\nexport const Type = {\n  Empty: \"\",\n  Wall: \"wall\",\n  Start: \"start\",\n  Goal: \"goal\",\n  Visited: \"visited\",\n  Path: \"path\",\n};\n\n// grid directions with no diagonals\nexport const directionsNoDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n];\n\n// grid directions with diagonals\nexport const directionsWithDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n  // diagonal\n  [1, 1], // bottom right\n  [1, -1], // up right\n  [-1, -1], // up left\n  [-1, 1], // bottom left\n];\n// shuffle an array (for randomizing directions)\nexport function shuffle(array) {\n  let rand, temp, cur;\n  for (cur = array.length - 1; cur > 0; cur--) {\n    rand = Math.floor(Math.random() * (cur + 1));\n    temp = array[cur];\n    array[cur] = array[rand];\n    array[rand] = temp;\n  }\n}\n\n// get neighbors given cell and diagonal movement boolean(ignores wall)\nexport function getNeighbors(grid, node, diag) {\n  if (!grid.length) {\n    return [];\n  }\n\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const directions = diag ? directionsWithDiag : directionsNoDiag;\n\n  let neighbors = [];\n  for (let i = 0; i < directions.length; i++) {\n    let dir = directions[i];\n    let newRow = node.row + dir[0];\n    let newCol = node.col + dir[1];\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol].nodeType !== Type.Wall\n    ) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n\n  return neighbors;\n}\n\n// A custom min/max heap (given comparator)\nexport class PriorityQueue {\n  constructor(comparator = (a, b) => a - b) {\n    this.heap = [];\n    this._comparator = comparator;\n  }\n\n  // cannot add null to heap\n  add(item) {\n    if (item === null) {\n      throw new Error(\"Item cannot be null!\");\n    }\n\n    // add to the end and heapify\n    this.heap.push(item);\n    this._swimUp(this.size() - 1);\n    return true;\n  }\n\n  // clear all items in heap\n  clear() {\n    this.heap = [];\n  }\n\n  // return null if heap is empty\n  peek() {\n    return this.size() === 0 ? null : this.heap[0];\n  }\n\n  // update item if item is modified (do nothing if not found)\n  updateItem(item) {\n    for (let i = 0; i < this.size(); i++) {\n      if (this.heap[i] === item) {\n        this._sinkDown(i);\n        this._swimUp(i);\n      }\n    }\n  }\n\n  // remove and return the min/max of the heap (return null if empty)\n  poll() {\n    if (this.size() <= 1) {\n      return this.heap.pop();\n    }\n\n    // swap the last node and root then heapify\n    let item = this.heap[0];\n    this.heap[0] = this.heap.pop();\n\n    this._sinkDown(0);\n    return item;\n  }\n\n  // return size of heap\n  size() {\n    return this.heap.length;\n  }\n\n  // true/false if heap is empty\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  // heapify a node with given index downwards\n  _sinkDown(index) {\n    let idx = index;\n    while (idx < this.size()) {\n      // both children\n      let left = 2 * idx + 1;\n      let right = 2 * idx + 2;\n      let smallest = idx;\n\n      // Sink down with the smallest children\n      if (\n        left < this.size() &&\n        this._comparator(this.heap[idx], this.heap[left]) > 0\n      ) {\n        smallest = left;\n      }\n\n      if (\n        right < this.size() &&\n        this._comparator(this.heap[smallest], this.heap[right]) > 0\n      ) {\n        smallest = right;\n      }\n\n      // if current node is the smallest, done\n      if (smallest === idx) {\n        return;\n      }\n\n      // swap\n      let temp = this.heap[idx];\n      this.heap[idx] = this.heap[smallest];\n      this.heap[smallest] = temp;\n\n      idx = smallest;\n    }\n  }\n\n  // heapify a node with given index upwards\n  _swimUp(index) {\n    let idx = index;\n    while (idx > 0) {\n      let parent = Math.floor((idx - 1) / 2);\n      // Swim up if parent is greater than children\n      if (this._comparator(this.heap[parent], this.heap[idx]) > 0) {\n        // swap\n        let temp = this.heap[parent];\n        this.heap[parent] = this.heap[idx];\n        this.heap[idx] = temp;\n\n        idx = parent;\n      } else {\n        return;\n      }\n    }\n  }\n}\n\n// A custom data structure for union find\nexport class DisjointSet {\n  constructor(numOfItems) {\n    // parent array\n    this.sets = new Array(numOfItems);\n    // size array\n    this.sizes = new Array(numOfItems);\n\n    for (let i = 0; i < numOfItems; i++) {\n      this.sets[i] = i;\n      this.sizes[i] = 1;\n    }\n  }\n\n  // merge two items' sets together\n  union(itemA, itemB) {\n    let rootA = this._getRoot(itemA);\n    let rootB = this._getRoot(itemB);\n\n    if (rootA === rootB) {\n      return;\n    }\n\n    if (this.sizes[rootA] < this.sizes[rootB]) {\n      // make rootA a subTree of rootB\n      this.sets[rootA] = rootB;\n      this.sizes[rootB] += this.sizes[rootA];\n    } else {\n      // make rootB a subTree of rootA\n      this.sets[rootB] = rootA;\n      this.sizes[rootA] += this.sizes[rootB];\n    }\n\n  }\n\n  // return if two items are in the same set\n  find(itemA, itemB) {\n    return this._getRoot(itemA) === this._getRoot(itemB);\n  }\n\n  // get root of current item\n  _getRoot(item) {\n    let index = item;\n    // while not the root of item (root of root is itself)\n    while (this.sets[index] !== index) {\n      index = this.sets[index];\n    }\n\n    return index;\n  }\n}\n","import {getNeighbors, PriorityQueue} from \"../utilities\";\n\n// Pathfinding with A*\nexport function aStar(grid, start, goal, diag, heuristic) {\n\n  // if heuristic function is not provided\n  if (heuristic === undefined) {\n    if (diag) {\n      // octile distance for diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return 1 * (dx + dy) + (Math.SQRT2 - 2 * 1) * Math.min(dx, dy);\n      };\n    } else {\n      // manhattan distance for non-diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return dx + dy;\n      };\n    }\n  }\n\n  // custom hash value for node\n  function key(node) {\n    return \"\".concat(node.row, \" \", node.col);\n  }\n\n  var open = new PriorityQueue((a, b) => {\n    return a.f - b.f;\n  });\n  var visitedInOrder = [];\n\n  // (K, V) => (node, path to node from start)\n  var dict = {};\n\n  start.distance = 0;\n  start.f = 0;\n  start.opened = true;\n  dict[key(start)] = [start];\n  open.add(start);\n\n  while (!open.isEmpty()) {\n    let node = open.poll();\n    node.closed = true;\n\n    visitedInOrder.push(node);\n    if (node === goal) {\n      // return path and visited nodes\n      return [dict[key(node)], visitedInOrder];\n    }\n\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      // 1 for no diagonal, SQRT2 for diagonal\n      let travelDistance =\n        neighbor.row - node.row === 0 || neighbor.col - node.col === 0\n          ? 1\n          : Math.SQRT2;\n      let newDistance = node.distance + travelDistance;\n\n      // if not processed or should be updated\n      if (!neighbor.opened || newDistance < neighbor.distance) {\n        neighbor.distance = newDistance;\n        neighbor.f = neighbor.distance + heuristic(neighbor, goal);\n\n        // push new path to hash table\n        dict[key(neighbor)] = dict[key(node)].slice();\n        dict[key(neighbor)].push(neighbor);\n\n        if (!neighbor.opened) {\n          open.add(neighbor);\n          neighbor.opened = true;\n        } else {\n          // update because we've updated f value\n          open.updateItem(neighbor);\n        }\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { dfs } from \"./dfs.js\";\nimport { bfs } from \"./bfs.js\";\nimport { dijkstra } from \"./dijkstra.js\";\nimport { aStar } from \"./aStar\";\n\n// Pathfinding algorithm selector\nexport const PATH_ALGO = {\n  \"A*\": aStar,\n  \"BFS\": bfs,\n  \"DFS\": dfs,\n  \"Dijkstra\": dijkstra,\n};\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Breadth First Search\nexport function bfs(grid, start, goal, diag) {\n  var q = [];\n  var visitedInOrder = [];\n\n  q.push([start, [start]]);\n\n  while (!!q.length) {\n    let [node, path] = q.shift();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to queue for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        q.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Depth First Search \nexport function dfs(grid, start, goal, diag) {\n  var stk = [];\n  var visitedInOrder = [];\n\n  stk.push([start, [start]]);\n\n  while (!!stk.length) {\n    let [node, path] = stk.pop();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to stack for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        stk.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { aStar } from \"./aStar\";\n\n// Path Finding with Dijkstra's Algorithm\nexport function dijkstra(grid, start, goal, diag) {\n  function heuristic(a, b) {\n    return 0;\n  }\n  // dijkstra is A* with no heuristic function\n  return aStar(grid, start, goal, diag, heuristic);\n}\n","import { Type, directionsNoDiag, shuffle } from \"../utilities\";\n\n// maze generator with recursive backtracking\nexport function backtrack(grid, start) {\n  let pathNodesInOrder = []\n  backtrackHelper(grid, start, pathNodesInOrder);\n  return pathNodesInOrder;\n}\n\nfunction backtrackHelper(grid, node, pathNodesInOrder) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  let randDirections = directionsNoDiag.slice();\n\n  shuffle(randDirections);\n  node.visited = true;\n\n  for (let i = 0; i < randDirections.length; i++) {\n    let direction = randDirections[i];\n    \n    // next node (2 becuase there are walls in between)\n    let newRow = node.row + 2 * direction[0];\n    let newCol = node.col + 2 * direction[1];\n\n    // if next node is within grid and visited (and not a goal)\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol] !== Type.Goal &&\n      !grid[newRow][newCol].visited\n    ) {\n\n      // midpoint of current node and next node\n      let dirRow = Math.floor((newRow + node.row) / 2);\n      let dirCol = Math.floor((newCol + node.col) / 2);\n\n      // add cells to path\n      pathNodesInOrder.push(node);\n      pathNodesInOrder.push(grid[dirRow][dirCol]);\n      pathNodesInOrder.push(grid[newRow][newCol]);\n\n      // backtrack\n      backtrackHelper(grid, grid[newRow][newCol], pathNodesInOrder);\n    }\n  }\n\n  return pathNodesInOrder;\n}\n","import { backtrack } from \"./backtrack.js\";\nimport { kruskal } from \"./kruskal.js\";\n\n// Maze Generation algorithm selector\nexport const MAZE_ALGO = {\n  \"Recursive Backtracker\": backtrack,\n  \"Kruskal's\": kruskal,\n};\n","import { DisjointSet, shuffle } from \"../utilities\";\n\n// maze generator with kruskal's algorithm (union find)\nexport function kruskal(grid, start) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  let pathNodesInOrder = [];\n\n  let edges = [];\n\n  for (let i = 0; i < rows; i += 2) {\n    for (let j = 0; j < cols; j += 2) {\n      // vertical path (2 rows below)\n      edges.push([i, j, [2, 0]]);\n      // horizontal path (2 cols to the right)\n      edges.push([i, j, [0, 2]]);\n    }\n  }\n\n  // shuffle path\n  shuffle(edges);\n\n  var forest = new DisjointSet(rows * cols);\n\n  while (!!edges.length) {\n    // get random path\n    let [row, col, direction] = edges.pop();\n\n    let newRow = row + direction[0];\n    let newCol = col + direction[1];\n\n    // node is represented by its number in grid\n    let indexA = row * rows + col;\n    let indexB = newRow * rows + newCol;\n\n    // neighbor node is out of bounds\n    if (newRow >= rows || newCol >= cols) {\n      continue;\n    }\n\n    // if current node and next node is not reachable\n    if (!forest.find(indexA, indexB)) {\n      // make it reachable\n      forest.union(indexA, indexB);\n\n      // midpoint of current node and next node\n      let dirRow = Math.floor((newRow + row) / 2);\n      let dirCol = Math.floor((newCol + col) / 2);\n\n      // push maze node\n      pathNodesInOrder.push(grid[row][col]);\n      pathNodesInOrder.push(grid[dirRow][dirCol]);\n      pathNodesInOrder.push(grid[newRow][newCol]);\n    }\n  }\n\n  return pathNodesInOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { Type } from \"./Algorithms/utilities\";\nimport { PATH_ALGO } from \"./Algorithms/PathFinding/algorithms\";\nimport { MAZE_ALGO } from \"./Algorithms/Maze/algorithms\";\n\nimport \"./Viz.css\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\n// Constants\n\nconst INITIAL_ROWS = 29;\nconst INITIAL_COLS = 57;\n\nconst INITIAL_START = { r: 10, c: 10 };\nconst INITIAL_GOAL = { r: 10, c: 46 };\n\nconst ANIMATION_SPEED = {\n  \"0.5x\": 96,\n  \"1x\": 48,\n  \"1.5x\": 36,\n  \"2x\": 24,\n  Instant: 0,\n};\n\nexport default class Viz extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // grid state\n      start: INITIAL_START,\n      goal: INITIAL_GOAL,\n      grid: this.initGrid(INITIAL_ROWS, INITIAL_COLS),\n\n      // current algorithm\n      pathAlgo: \"\",\n      mazeAlgo: \"\",\n\n      // algorithm stats\n      pathLength: 0,\n      time: 0,\n\n      // diagonal movement\n      diag: false,\n\n      // mouse states\n      dragType: Type.Empty,\n      disabled: false,\n      mouseIsPressed: false,\n\n      // current animation speed\n      animationSpeed: ANIMATION_SPEED[\"1x\"],\n    };\n  }\n\n  // Init Mount (Tab Name, Disable Button)\n  componentDidMount() {\n    document.title = \"Path Visualizer\";\n    document.getElementById(\"path-button\").disabled = true;\n    document.getElementById(\"maze-button\").disabled = true;\n  }\n\n  /* Grid Functions */\n\n  // initial grid functions\n  initGrid(rows, cols) {\n    const grid = [];\n    for (let row = 0; row < rows; row++) {\n      const curRow = [];\n      for (let col = 0; col < cols; col++) {\n        let assignType = Type.Empty;\n        if (INITIAL_START.r === row && INITIAL_START.c === col) {\n          assignType = Type.Start;\n        }\n        if (INITIAL_GOAL.r === row && INITIAL_GOAL.c === col) {\n          assignType = Type.Goal;\n        }\n\n        // initial node properties\n        let node = {\n          row: row,\n          col: col,\n          prevNodeType: Type.Empty,\n          nodeType: assignType,\n          visited: false,\n          distance: Infinity,\n          f: Infinity,\n          opened: false,\n          closed: false,\n        };\n\n        curRow.push(node);\n      }\n      grid.push(curRow);\n    }\n    return grid;\n  }\n\n  // clear all the wall/visited/path nodes\n  clearBoard() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[r].length; c++) {\n        const curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(r, c, Type.Empty);\n        } else {\n          // prevent from start/goal reverting to anything other than empty nodes\n          grid[r][c].prevNodeType = Type.Empty;\n        }\n      }\n    }\n\n    // clear stats\n    this.displayStats(0, 0);\n\n    this.setState(grid);\n  }\n\n  // clear node caches before starting next search/animation\n  clearCache() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        // clear data\n        grid[r][c].visited = false;\n        grid[r][c].opened = false;\n        grid[r][c].closed = false;\n\n        grid[r][c].distance = Infinity;\n        grid[r][c].f = Infinity;\n\n        let curType = grid[r][c].nodeType;\n\n        // clear visited cache\n        if (curType === Type.Visited || curType === Type.Path) {\n          this.setNodeType(r, c, Type.Empty);\n        }\n\n        // prevent from reverting to types from previous search\n        grid[r][c].prevNodeType = Type.Empty;\n      }\n    }\n\n    this.setState(grid);\n  }\n\n  /* Node Functions */\n\n  // set node given type, set current type to previous type accordingly\n  setNodeType(row, col, assignType) {\n    const { grid } = this.state;\n    if (grid[row][col].nodeType !== assignType) {\n      grid[row][col].prevNodeType = grid[row][col].nodeType;\n    }\n    grid[row][col].nodeType = assignType;\n  }\n\n  // revert node type to its previous  type\n  revertNodeType(row, col) {\n    const { grid } = this.state;\n    grid[row][col].nodeType = grid[row][col].prevNodeType;\n  }\n\n  /* Mouse Events */\n\n  // mouse down event\n  handleMouseDown(row, col) {\n    const { grid, disabled } = this.state;\n\n    if (disabled) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n\n    switch (curType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        this.setNodeType(row, col, Type.Wall);\n        break;\n      case Type.Wall:\n        // revert wall nodes to previous type\n        this.revertNodeType(row, col);\n        break;\n      default:\n        break;\n    }\n\n    this.setState({\n      grid: grid,\n      dragType: curType,\n      mouseIsPressed: true,\n    });\n  }\n\n  // mouse hover event\n  handleMouseEnter(row, col) {\n    const {\n      grid,\n      start,\n      goal,\n      disabled,\n      mouseIsPressed,\n      dragType,\n    } = this.state;\n\n    // ignore if disabled or mouse is not pressed\n    if (disabled || !mouseIsPressed) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n    switch (dragType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(row, col, Type.Wall);\n        }\n        break;\n      case Type.Wall:\n        // revert to previous types\n        if (curType === Type.Wall) {\n          this.revertNodeType(row, col);\n        }\n        break;\n      case Type.Start:\n        // move start and revert previous start\n        if (curType !== Type.Wall && curType !== Type.Goal) {\n          this.revertNodeType(start.r, start.c);\n          this.setNodeType(row, col, Type.Start);\n          this.setState({ start: { r: row, c: col } });\n        }\n        break;\n      case Type.Goal:\n        // move goal and revert previous goal\n        if (curType !== Type.Wall && curType !== Type.Start) {\n          this.revertNodeType(goal.r, goal.c);\n          this.setNodeType(row, col, Type.Goal);\n          this.setState({ goal: { r: row, c: col } });\n        }\n        break;\n      default:\n    }\n\n    this.setState(grid);\n  }\n\n  // mouse up event\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  /* Pathfinding Algorithm Functions */\n\n  // disable all inputs\n  disableInput() {\n    // disable selects and button\n    var elements = document.querySelectorAll(\"button\");\n    elements.forEach((element) => (element.disabled = true));\n    this.setState({ disabled: true });\n  }\n\n  // enable all inputs\n  enableInput() {\n    const { pathAlgo, mazeAlgo } = this.state;\n\n    // enable if not default mode\n    if (pathAlgo !== \"---\") {\n      document.getElementById(\"path-button\").disabled = false;\n    }\n\n    // enable if not default mode\n    if (mazeAlgo !== \"---\") {\n      document.getElementById(\"maze-button\").disabled = false;\n    }\n\n    document.getElementById(\"clear-button\").disabled = false;\n\n    this.setState({ disabled: false });\n  }\n\n  // set diagonal movement\n  setDiag(event) {\n    this.setState({ diag: event.target.checked });\n  }\n\n  // set pathfinding algorithm\n  setPathAlgo(event) {\n    const { disabled } = this.state;\n    let mode = event.target.value;\n\n    if (!(mode in PATH_ALGO)) {\n      // not a valid algorithm\n      return;\n    }\n\n    // enable button if not default option or during animation\n    if (!disabled && mode !== \"---\") {\n      document.getElementById(\"path-button\").disabled = false;\n    }\n\n    this.setState({ pathAlgo: mode });\n  }\n\n  // calculate path length\n  getPathLength(path) {\n    let length = 0;\n    for (let i = 0; i < path.length - 1; i++) {\n      let curNode = path[i];\n      let nextNode = path[i + 1];\n      let dx = Math.abs(curNode.row - nextNode.row);\n      let dy = Math.abs(curNode.col - nextNode.col);\n\n      length += dx === 0 || dy === 0 ? 1 : Math.SQRT2;\n    }\n\n    return length;\n  }\n\n  // display stats\n  displayStats(length, time) {\n    this.setState({ pathLength: length, time: time });\n\n    document.getElementById(\"length\").className =\n      length === 0 ? \"hide\" : \"show\";\n\n    document.getElementById(\"time\").className = time === 0 ? \"hide\" : \"show\";\n  }\n\n  // animate pathfinding algorithms\n  animateSearch() {\n    const { grid, start, goal, pathAlgo, diag, animationSpeed } = this.state;\n\n    // clear cache\n    this.clearCache();\n\n    let t0 = performance.now();\n\n    // perform search\n    const [path, visitedInOrder] = PATH_ALGO[pathAlgo](\n      grid,\n      grid[start.r][start.c],\n      grid[goal.r][goal.c],\n      diag\n    );\n\n    // get execution time\n    let executionTime = performance.now() - t0;\n\n    // get path length\n    let length = this.getPathLength(path);\n\n    // display stats\n    this.displayStats(length, executionTime);\n\n    // disable input during animation\n    this.disableInput();\n\n    // concatenate all nodes to animate\n    const nodesToAnimate = visitedInOrder.concat(path);\n\n    for (let i = 0; i < nodesToAnimate.length; i++) {\n      let node = nodesToAnimate[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        if (\n          node.nodeType === Type.Start &&\n          nodesToAnimate.length === visitedInOrder.length\n        ) {\n          // no path found\n          node.prevNodeType = Type.Visited;\n          continue;\n        }\n        // set start/goal nodes previous type to path for indicate path when moving start/goal\n        node.prevNodeType = Type.Path;\n        continue;\n      }\n\n      let assignType = i < visitedInOrder.length ? Type.Visited : Type.Path;\n\n      // setTimeout does not work with 0ms\n      if (animationSpeed !== 0) {\n        setTimeout(() => {\n          node.nodeType = assignType;\n          // set state for new render (force animation)\n          this.setState({ grid });\n        }, animationSpeed * i);\n      } else {\n        node.nodeType = assignType;\n      }\n    }\n\n    // enable input after animation\n    setTimeout(() => {\n      this.enableInput();\n    }, animationSpeed * nodesToAnimate.length);\n  }\n\n  /* Maze Functions */\n\n  // set maze generation algorithm\n  setMazeAlgo(event) {\n    const { disabled } = this.state;\n    let mode = event.target.value;\n\n    if (!(mode in MAZE_ALGO)) {\n      // not a valid algorithm\n      return;\n    }\n\n    // enable button if not default option or during animation\n    if (!disabled && mode !== \"---\") {\n      document.getElementById(\"maze-button\").disabled = false;\n    }\n\n    this.setState({ mazeAlgo: mode });\n  }\n\n  // animate maze generation\n  generateMaze() {\n    const { grid, start, animationSpeed, mazeAlgo } = this.state;\n\n    let t0 = performance.now();\n\n    let pathNodesInOrder = MAZE_ALGO[mazeAlgo](grid, grid[start.r][start.c]);\n\n    let executionTime = performance.now() - t0;\n\n    this.displayStats(0, executionTime);\n\n    // clear all cache\n    this.clearCache();\n\n    // disable input during animation\n    this.disableInput();\n\n    // set all cells to wall\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        let curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          // Walls with no zoom effect\n          this.setNodeType(r, c, Type.Wall);\n        }\n      }\n    }\n\n    // force render\n    this.setState({ grid });\n\n    // animation maze\n    for (let i = 0; i < pathNodesInOrder.length; i++) {\n      let node = pathNodesInOrder[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        continue;\n      }\n\n      // setTimeout does not work with 0ms\n      if (animationSpeed !== 0) {\n        setTimeout(() => {\n          node.nodeType = Type.Empty;\n          // set state for new render (force animation)\n          this.setState({ grid });\n        }, animationSpeed * i);\n      } else {\n        node.nodeType = Type.Empty;\n      }\n    }\n\n    // enable input after animation\n    setTimeout(() => {\n      this.enableInput();\n    }, animationSpeed * pathNodesInOrder.length);\n\n    this.setState({ grid });\n  }\n\n  // set animation speed\n  setAnimationSpeed(event) {\n    let speed = event.target.value;\n\n    if (!(speed in ANIMATION_SPEED)) {\n      // not a valid algorithm\n      return;\n    }\n    console.log(speed);\n    this.setState({ animationSpeed: ANIMATION_SPEED[speed] });\n  }\n\n  /* Render */\n\n  render() {\n    const { grid, pathLength, time } = this.state;\n\n    return (\n      <>\n        <div className=\"panel\">\n          <div className=\"title\">\n            <p className=\"h1\">MazeViz</p>\n            <footer>\n              Project Hosted on\n              <a href=\"https://github.com/BenjaminTu/mazeviz\"> Github</a>\n            </footer>\n          </div>\n\n          <div className=\"left\">\n            <small className=\"path-title\">Pathfinding Algorithm:</small>\n            <select\n              id=\"path\"\n              className=\"d-block m-2 top\"\n              onChange={(e) => this.setPathAlgo(e)}\n            >\n              <option selected disabled>\n                ---\n              </option>\n              {Object.keys(PATH_ALGO).map((option, index) => (\n                <option key={index} value={option}>\n                  {option}\n                </option>\n              ))}\n            </select>\n\n            <label className=\"bot\">\n              <input\n                type=\"checkbox\"\n                className=\"checkbox mr-1\"\n                onChange={(e) => this.setDiag(e)}\n              ></input>\n              Allow Diagonal Movement\n            </label>\n\n            <button\n              id=\"path-button\"\n              className=\"btn btn-sm btn-success m-2 rt\"\n              onClick={() => this.animateSearch()}\n            >\n              Search Path\n            </button>\n          </div>\n\n          <div className=\"right\">\n            <button\n              id=\"clear-button\"\n              className=\"btn btn btn-primary d-block m-2\"\n              onClick={() => this.clearBoard()}\n            >\n              Clear Board\n            </button>\n          </div>\n\n          <div className=\"middle\">\n            <small className=\"path-title\">Maze Generation Algorithm:</small>\n            <select\n              id=\"maze\"\n              className=\"lt\"\n              onChange={(e) => this.setMazeAlgo(e)}\n            >\n              <option selected disabled>\n                ---\n              </option>\n              {Object.keys(MAZE_ALGO).map((option, index) => (\n                <option key={index} value={option}>\n                  {option}\n                </option>\n              ))}\n            </select>\n\n            <button\n              id=\"maze-button\"\n              className=\"btn btn-sm btn-success m-2 rtrt\"\n              onClick={() => this.generateMaze()}\n            >\n              Generate Maze\n            </button>\n          </div>\n\n          <div className=\"knob\">\n            <small>Speed:</small>\n            <select className=\"m-2 lt\" onChange={(e) => this.setAnimationSpeed(e)}>\n              {Object.keys(ANIMATION_SPEED).map((option, index) => (\n                <option key={index} value={option} selected={option === \"1x\"}>\n                  {option}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div className=\"stats\">\n            <small className=\"show m-2\">Algorithm Stats:</small>\n            <div className=\"stats-panel\">\n              <small id=\"length\" className=\"h6 hide\">\n                path length: {pathLength.toFixed(2)} unit\n              </small>\n              <br></br>\n              <small id=\"time\" className=\"h6 hide\">\n                time taken: {time.toFixed(2)} ms\n              </small>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"flex-container grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx} className=\"flex-nowrap d-flex justify-content-center overflow-hidden\">\n                  {row.map((node, nodeIdx) => {\n                    const { row, col, nodeType } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        row={row}\n                        col={col}\n                        nodeType={nodeType}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                      ></Node>\n                    );\n                  })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n","import \"./App.css\";\nimport Viz from \"./Viz/Viz\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {\" \"}\n      <Viz></Viz>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}