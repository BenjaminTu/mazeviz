{"version":3,"sources":["Viz/Node/Node.jsx","Viz/Algorithms/utilities.js","Viz/Algorithms/PathFinding/aStar.js","Viz/Algorithms/PathFinding/algorithms.js","Viz/Algorithms/PathFinding/bfs.js","Viz/Algorithms/PathFinding/dfs.js","Viz/Algorithms/PathFinding/dijkstra.js","Viz/Algorithms/Maze/backtrack.js","Viz/Viz.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","nodeType","onMouseDown","onMouseEnter","onMouseUp","className","concat","trim","Component","Type","directionsNoDiag","directionsWithDiag","getNeighbors","grid","node","diag","length","rows","cols","directions","neighbors","i","dir","newRow","newCol","push","PriorityQueue","comparator","a","b","heap","_comparator","item","Error","_swimUp","size","_sinkDown","pop","index","idx","left","right","smallest","temp","parent","Math","floor","aStar","start","goal","heuristic","key","undefined","dx","abs","dy","SQRT2","min","console","log","open","f","visitedInOrder","dict","distance","opened","add","isEmpty","poll","closed","neighbor","travelDistance","newDistance","slice","updateItem","Algo","q","shift","path","visited","newPath","stk","backtrack","pathNodesInOrder","randDirections","array","rand","cur","random","shuffle","direction","dirRow","dirCol","INITIAL_START","r","c","INITIAL_GOAL","Viz","state","initGrid","pathAlgo","dragType","disabled","mouseIsPressed","animationSpeed","curRow","assignType","prevNodeType","Infinity","curType","setNodeType","setState","revertNodeType","document","querySelectorAll","forEach","element","event","target","checked","mode","value","clearCache","disableInput","nodesToAnimate","setTimeout","enableInput","onClick","clearBoard","type","id","onChange","e","setDiag","htmlFor","setPathAlgo","Object","keys","map","option","animateSearch","generateMaze","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.ca87ad69.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      nodeType,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n\n    return (\n      <div\n        // render by type\n        className={\"node\".concat(\" \", nodeType).trim()}\n        // mouse event functions\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","// node types\nexport const Type = {\n  Empty: \"\",\n  Wall: \"wall\",\n  Start: \"start\",\n  Goal: \"goal\",\n  Visited: \"visited\",\n  Path: \"path\",\n};\n\n// grid directions with no diagonals\nexport const directionsNoDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n];\n\n// grid directions with diagonals\nexport const directionsWithDiag = [\n  [0, -1], // left\n  [1, 0], // down\n  [0, 1], // right\n  [-1, 0], // up\n  // diagonal\n  [1, 1], // bottom right\n  [1, -1], // up right\n  [-1, -1], // up left\n  [-1, 1], // bottom left\n];\n// shuffle an array (for randomizing directions)\nexport function shuffle(array) {\n  let rand, temp, cur;\n  for (cur = array.length - 1; cur > 0; cur--) {\n    rand = Math.floor(Math.random() * (cur + 1));\n    temp = array[cur];\n    array[cur] = array[rand];\n    array[rand] = temp;\n  }\n}\n\n// get neighbors given cell and diagonal movement boolean(ignores wall)\nexport function getNeighbors(grid, node, diag) {\n  if (!grid.length) {\n    return [];\n  }\n\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const directions = diag ? directionsWithDiag : directionsNoDiag;\n\n  let neighbors = [];\n  for (let i = 0; i < directions.length; i++) {\n    let dir = directions[i];\n    let newRow = node.row + dir[0];\n    let newCol = node.col + dir[1];\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol].nodeType !== Type.Wall\n    ) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n\n  return neighbors;\n}\n\n// A custom min/max heap (given comparator)\nexport class PriorityQueue {\n  constructor(comparator = (a, b) => a - b) {\n    this.heap = [];\n    this._comparator = comparator;\n  }\n\n  // cannot add null to heap\n  add(item) {\n    if (item === null) {\n      throw new Error(\"Item cannot be null!\");\n    }\n\n    // add to the end and heapify\n    this.heap.push(item);\n    this._swimUp(this.size() - 1);\n    return true;\n  }\n\n  // clear all items in heap\n  clear() {\n    this.heap = [];\n  }\n\n  // return null if heap is empty\n  peek() {\n    return this.size() === 0 ? null : this.heap[0];\n  }\n\n  // update item if item is modified (do nothing if not found)\n  updateItem(item) {\n    for (let i = 0; i < this.size(); i++) {\n      if (this.heap[i] === item) {\n        this._sinkDown(i);\n        this._swimUp(i);\n      }\n    }\n  }\n\n  // remove and return the min/max of the heap (return null if empty)\n  poll() {\n    if (this.size() <= 1) {\n      return this.heap.pop();\n    }\n\n    // swap the last node and root then heapify\n    let item = this.heap[0];\n    this.heap[0] = this.heap.pop();\n\n    this._sinkDown(0);\n    return item;\n  }\n\n  // return size of heap\n  size() {\n    return this.heap.length;\n  }\n\n  // true/false if heap is empty\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  // heapify a node with given index downwards\n  _sinkDown(index) {\n    let idx = index;\n    while (idx < this.size()) {\n      // both children\n      let left = 2 * idx + 1;\n      let right = 2 * idx + 2;\n      let smallest = idx;\n\n      // Sink down with the smallest children\n      if (\n        left < this.size() &&\n        this._comparator(this.heap[idx], this.heap[left]) > 0\n      ) {\n        smallest = left;\n      }\n\n      if (\n        right < this.size() &&\n        this._comparator(this.heap[smallest], this.heap[right]) > 0\n      ) {\n        smallest = right;\n      }\n\n      // if current node is the smallest, done\n      if (smallest === idx) {\n        return;\n      }\n\n      // swap\n      let temp = this.heap[idx];\n      this.heap[idx] = this.heap[smallest];\n      this.heap[smallest] = temp;\n\n      idx = smallest;\n    }\n  }\n\n  // heapify a node with given index upwards\n  _swimUp(index) {\n    let idx = index;\n    while (idx > 0) {\n      let parent = Math.floor((idx - 1) / 2);\n      // Swim up if parent is greater than children\n      if (this._comparator(this.heap[parent], this.heap[idx]) > 0) {\n        // swap\n        let temp = this.heap[parent];\n        this.heap[parent] = this.heap[idx];\n        this.heap[idx] = temp;\n\n        idx = parent;\n      } else {\n        return;\n      }\n    }\n  }\n}\n","import {getNeighbors, PriorityQueue} from \"../utilities\";\n\n// Pathfinding with A*\nexport function aStar(grid, start, goal, diag, heuristic) {\n\n  // if heuristic function is not provided\n  if (heuristic === undefined) {\n    if (diag) {\n      // octile distance for diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return 1 * (dx + dy) + (Math.SQRT2 - 2 * 1) * Math.min(dx, dy);\n      };\n    } else {\n      // manhattan distance for non-diagonal movements\n      heuristic = function (a, b) {\n        let dx = Math.abs(a.row - b.row);\n        let dy = Math.abs(a.col - b.col);\n\n        return dx + dy;\n      };\n    }\n  }\n\n  // custom hash value for node\n  function key(node) {\n    return \"\".concat(node.row, \" \", node.col);\n  }\n\n  console.log(heuristic);\n\n  var open = new PriorityQueue((a, b) => {\n    return a.f - b.f;\n  });\n  var visitedInOrder = [];\n\n  // (K, V) => (node, path to node from start)\n  var dict = {};\n\n  start.distance = 0;\n  start.f = 0;\n  start.opened = true;\n  dict[key(start)] = [start];\n  open.add(start);\n\n  while (!open.isEmpty()) {\n    let node = open.poll();\n    node.closed = true;\n\n    visitedInOrder.push(node);\n    if (node === goal) {\n      // return path and visited nodes\n      return [dict[key(node)], visitedInOrder];\n    }\n\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (neighbor.closed) {\n        continue;\n      }\n\n      // 1 for no diagonal, SQRT2 for diagonal\n      let travelDistance =\n        neighbor.row - node.row === 0 || neighbor.col - node.col === 0\n          ? 1\n          : Math.SQRT2;\n      let newDistance = node.distance + travelDistance;\n\n      // if not processed or should be updated\n      if (!neighbor.opened || newDistance < neighbor.distance) {\n        neighbor.distance = newDistance;\n        neighbor.f = neighbor.distance + heuristic(neighbor, goal);\n\n        // push new path to hash table\n        dict[key(neighbor)] = dict[key(node)].slice();\n        dict[key(neighbor)].push(neighbor);\n\n        if (!neighbor.opened) {\n          open.add(neighbor);\n          neighbor.opened = true;\n        } else {\n          // update because we've updated f value\n          open.updateItem(neighbor);\n        }\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { dfs } from \"./dfs.js\";\nimport { bfs } from \"./bfs.js\";\nimport { dijkstra } from \"./dijkstra.js\";\nimport { aStar } from \"./aStar\";\n\n// Pathfinding algorithm selector\nexport const Algo = {\n  \"---\": function init() {\n    return [[], []];\n  },\n  \"A*\": aStar,\n  \"BFS\": bfs,\n  \"DFS\": dfs,\n  \"Dijkstra\": dijkstra,\n};\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Breadth First Search\nexport function bfs(grid, start, goal, diag) {\n  var q = [];\n  var visitedInOrder = [];\n\n  q.push([start, [start]]);\n\n  while (!!q.length) {\n    let [node, path] = q.shift();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to queue for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        q.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import {getNeighbors} from \"../utilities\";\n\n// Pathfinding with Depth First Search \nexport function dfs(grid, start, goal, diag) {\n  var stk = [];\n  var visitedInOrder = [];\n\n  stk.push([start, [start]]);\n\n  while (!!stk.length) {\n    let [node, path] = stk.pop();\n\n    if (node.visited) {\n      continue;\n    }\n\n    node.visited = true;\n    visitedInOrder.push(node);\n    if (node === goal) {\n      return [path, visitedInOrder];\n    }\n\n    // push to stack for every not-yet-visited neighbor\n    let neighbors = getNeighbors(grid, node, diag);\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (!neighbor.visited) {\n        let newPath = path.slice();\n        newPath.push(neighbor);\n        stk.push([neighbor, newPath]);\n      }\n    }\n  }\n\n  // no path found\n  return [[], visitedInOrder];\n}\n","import { aStar } from \"./aStar\";\n\n// Path Finding with Dijkstra's Algorithm\nexport function dijkstra(grid, start, goal, diag) {\n  function heuristic(a, b) {\n    return 0;\n  }\n  // dijkstra is A* with no heuristic function\n  return aStar(grid, start, goal, diag, heuristic);\n}\n","import { Type, directionsNoDiag, shuffle } from \"../utilities\";\n\n// maze generator with recursive bcktracking\nexport function backtrack(grid, node, pathNodesInOrder) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  let randDirections = directionsNoDiag.slice();\n\n  shuffle(randDirections);\n  node.visited = true;\n\n  for (let i = 0; i < randDirections.length; i++) {\n    let direction = randDirections[i];\n    \n    // next node (2 becuase there are walls in between)\n    let newRow = node.row + 2 * direction[0];\n    let newCol = node.col + 2 * direction[1];\n\n    // if next node is within grid and visited (and not a goal)\n    if (\n      newRow >= 0 &&\n      newCol >= 0 &&\n      newRow < rows &&\n      newCol < cols &&\n      grid[newRow][newCol] !== Type.Goal &&\n      !grid[newRow][newCol].visited\n    ) {\n      /* visual illustration (n for next node, p for path, w for wall)\n       * w w w w\n       * w n w w\n       * w p w w\n       * w p w w\n       *\n       * // next iteration\n       *\n       * w w w w\n       * w p p n\n       * w p w w\n       * w p w w\n       */\n\n      // midpoint of current node nad next node\n      let dirRow = Math.floor((newRow + node.row) / 2);\n      let dirCol = Math.floor((newCol + node.col) / 2);\n\n      // add cells to path\n      pathNodesInOrder.push(node);\n      pathNodesInOrder.push(grid[dirRow][dirCol]);\n\n      // backtrack\n      backtrack(grid, grid[newRow][newCol], pathNodesInOrder);\n    }\n  }\n\n  return pathNodesInOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { Type } from \"./Algorithms/utilities\";\nimport { Algo } from \"./Algorithms/PathFinding/algorithms\";\nimport { backtrack } from \"./Algorithms/Maze/backtrack\";\n\nimport \"./Viz.css\";\n\n// Constants\n\nconst INITIAL_ROWS = 27;\nconst INITIAL_COLS = 51;\n\nconst INITIAL_START = { r: 10, c: 10 };\nconst INITIAL_GOAL = { r: 10, c: 43 };\n\nconst ANIMATION_SPEED = 20;\n\nexport default class Viz extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // grid state\n      start: INITIAL_START,\n      goal: INITIAL_GOAL,\n      grid: this.initGrid(INITIAL_ROWS, INITIAL_COLS),\n\n      // current pathfinding algorithm\n      pathAlgo: \"---\",\n\n      // diagonal movement\n      diag: false,\n\n      // mouse states\n      dragType: Type.Empty,\n      disabled: false,\n      mouseIsPressed: false,\n\n      // current animation speed\n      animationSpeed: ANIMATION_SPEED,\n    };\n  }\n\n  /* Grid Functions */\n\n  // initial grid functions\n  initGrid(rows, cols) {\n    const grid = [];\n    for (let row = 0; row < rows; row++) {\n      const curRow = [];\n      for (let col = 0; col < cols; col++) {\n        let assignType = Type.Empty;\n        if (INITIAL_START.r === row && INITIAL_START.c === col) {\n          assignType = Type.Start;\n        }\n        if (INITIAL_GOAL.r === row && INITIAL_GOAL.c === col) {\n          assignType = Type.Goal;\n        }\n\n        // initial node properties\n        let node = {\n          row: row,\n          col: col,\n          prevNodeType: Type.Empty,\n          nodeType: assignType,\n          visited: false,\n          distance: Infinity,\n          f: Infinity,\n          opened: false,\n          closed: false,\n        };\n\n        curRow.push(node);\n      }\n      grid.push(curRow);\n    }\n    return grid;\n  }\n\n  // clear all the wall/visited/path nodes\n  clearBoard() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[r].length; c++) {\n        const curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(r, c, Type.Empty);\n        } else {\n          // prevent from start/goal reverting to anything other than empty nodes\n          grid[r][c].prevNodeType = Type.Empty;\n        }\n      }\n    }\n\n    this.setState(grid);\n  }\n\n  // clear node caches before starting next search/animation\n  clearCache() {\n    const { grid } = this.state;\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        // clear data\n        grid[r][c].visited = false;\n        grid[r][c].opened = false;\n        grid[r][c].closed = false;\n\n        grid[r][c].distance = Infinity;\n        grid[r][c].f = Infinity;\n\n        let curType = grid[r][c].nodeType;\n\n        // clear visited cache\n        if (curType === Type.Visited || curType === Type.Path) {\n          this.setNodeType(r, c, Type.Empty);\n        } else if (curType === Type.Wall) {\n          // prevent from reverting to types from previous search\n          grid[r][c].prevNodeType = Type.Empty;\n        }\n      }\n    }\n\n    this.setState(grid);\n  }\n\n  /* Node Functions */\n\n  // set node given type, set current type to previous type accordingly\n  setNodeType(row, col, assignType) {\n    const { grid } = this.state;\n    if (grid[row][col].nodeType !== assignType) {\n      grid[row][col].prevNodeType = grid[row][col].nodeType;\n    }\n    grid[row][col].nodeType = assignType;\n  }\n\n  // revert node type to its previous  type\n  revertNodeType(row, col) {\n    const { grid } = this.state;\n    grid[row][col].nodeType = grid[row][col].prevNodeType;\n  }\n\n  /* Mouse Events */\n\n  // mouse down event\n  handleMouseDown(row, col) {\n    const { grid, disabled } = this.state;\n\n    if (disabled) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n\n    switch (curType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        this.setNodeType(row, col, Type.Wall);\n        break;\n      case Type.Wall:\n        // revert wall nodes to previous type\n        this.revertNodeType(row, col);\n        break;\n      default:\n        break;\n    }\n\n    this.setState({\n      grid: grid,\n      dragType: curType,\n      mouseIsPressed: true,\n    });\n  }\n\n  // mouse hover event\n  handleMouseEnter(row, col) {\n    const {\n      grid,\n      start,\n      goal,\n      disabled,\n      mouseIsPressed,\n      dragType,\n    } = this.state;\n\n    // ignore if disabled or mouse is not pressed\n    if (disabled || !mouseIsPressed) {\n      return;\n    }\n\n    const curType = grid[row][col].nodeType;\n    switch (dragType) {\n      case Type.Empty:\n      case Type.Visited:\n      case Type.Path:\n        // set empty/visited/path nodes to wall\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(row, col, Type.Wall);\n        }\n        break;\n      case Type.Wall:\n        // revert to previous types\n        if (curType === Type.Wall) {\n          this.revertNodeType(row, col);\n        }\n        break;\n      case Type.Start:\n        // move start and revert previous start\n        if (curType !== Type.Wall && curType !== Type.Goal) {\n          this.revertNodeType(start.r, start.c);\n          this.setNodeType(row, col, Type.Start);\n          this.setState({ start: { r: row, c: col } });\n        }\n        break;\n      case Type.Goal:\n        // move goal and revert previous goal\n        if (curType !== Type.Wall && curType !== Type.Start) {\n          this.revertNodeType(goal.r, goal.c);\n          this.setNodeType(row, col, Type.Goal);\n          this.setState({ goal: { r: row, c: col } });\n        }\n        break;\n      default:\n    }\n\n    this.setState(grid);\n  }\n\n  // mouse up event\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  /* Pathfinding Algorithm Functions */\n\n  // disable all inputs\n  disableInput() {\n    var elements = document.querySelectorAll(\"button, input\");\n    elements.forEach((element) => (element.disabled = true));\n    this.setState({ disabled: true });\n  }\n\n  // enable all inputs\n  enableInput() {\n    var elements = document.querySelectorAll(\"button, input\");\n    elements.forEach((element) => (element.disabled = false));\n    this.setState({ disabled: false });\n  }\n\n  // set diagonal movement\n  setDiag(event) {\n    this.setState({ diag: event.target.checked });\n  }\n\n  // set pathfinding algorithm\n  setPathAlgo(event) {\n    let mode = event.target.value;\n\n    if (!(mode in Algo)) {\n      // not a valid algorithm\n      return;\n    }\n    this.setState({ pathAlgo: mode });\n  }\n\n  // animate pathfinding algorithms\n  animateSearch() {\n    const { grid, start, goal, pathAlgo, diag, animationSpeed } = this.state;\n\n    // clear cache\n    this.clearCache();\n\n    // perform search\n    const [path, visitedInOrder] = Algo[pathAlgo](\n      grid,\n      grid[start.r][start.c],\n      grid[goal.r][goal.c],\n      diag\n    );\n\n    // disable input during animation\n    this.disableInput();\n\n    // concatenate all nodes to animate\n    const nodesToAnimate = visitedInOrder.concat(path);\n\n    for (let i = 0; i < nodesToAnimate.length; i++) {\n      let node = nodesToAnimate[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        // set start/goal nodes previous type to path for indicate path when moving start/goal\n        node.prevNodeType = Type.Path;\n        continue;\n      }\n\n      let assignType = i < visitedInOrder.length ? Type.Visited : Type.Path;\n      setTimeout(() => {\n        node.nodeType = assignType;\n\n        // set state for new render (force animation)\n        this.setState({ grid });\n      }, animationSpeed * i);\n    }\n\n    // enable input after animation\n    setTimeout(() => {\n      this.enableInput();\n    }, animationSpeed * nodesToAnimate.length);\n  }\n\n  /* Maze Functions */\n\n  // animate maze generation\n  generateMaze() {\n    const { grid, start, animationSpeed } = this.state;\n\n    let pathNodesInOrder = [];\n    backtrack(grid, grid[start.r][start.c], pathNodesInOrder);\n\n    // clear all cache\n    this.clearCache();\n\n    // disable input during animation\n    this.disableInput();\n\n    // set all cells to wall\n    for (let r = 0; r < grid.length; r++) {\n      for (let c = 0; c < grid[0].length; c++) {\n        let curType = grid[r][c].nodeType;\n        if (curType !== Type.Start && curType !== Type.Goal) {\n          this.setNodeType(r, c, Type.Wall);\n        }\n      }\n    }\n\n    // force render\n    this.setState({ grid });\n\n    // animation maze\n    for (let i = 0; i < pathNodesInOrder.length; i++) {\n      let node = pathNodesInOrder[i];\n      if (node.nodeType === Type.Start || node.nodeType === Type.Goal) {\n        continue;\n      }\n      setTimeout(() => {\n        node.nodeType = Type.Empty;\n        // set state for new render (force animation)\n        this.setState({ grid });\n      }, animationSpeed * i);\n    }\n\n    // enable input after animation\n    this.enableInput(animationSpeed * pathNodesInOrder.length);\n  }\n\n  /* Render */\n\n  render() {\n    const { grid } = this.state;\n\n    return (\n      <>\n        <div className=\"panel\">\n          <button onClick={() => this.clearBoard()}> Clear Board </button>\n          <input type=\"checkbox\" id=\"checkbox\" onChange={(e) => this.setDiag(e)}></input>\n          <label htmlFor=\"checkbox\">Allow Diagonal Movements</label>\n          <select id=\"select\" onChange={(e) => this.setPathAlgo(e)}>\n            {Object.keys(Algo).map((option, index) => (\n              <option key={index} value={option}>\n                {option}\n              </option>\n            ))}\n          </select>\n          <button onClick={() => this.animateSearch()}>Start Search</button>\n          <button onClick={() => this.generateMaze()}>Generate Maze</button>\n        </div>\n\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, nodeType } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      row={row}\n                      col={col}\n                      nodeType={nodeType}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n","import \"./App.css\";\nimport Viz from \"./Viz/Viz\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {\" \"}\n      <Viz></Viz>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}